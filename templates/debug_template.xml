<template name="mydebugtemplate" value="#pragma once&#10;&#10;#define _CRT_SECURE_NO_WARNINGS&#10;&#10;#include &lt;iostream&gt;&#10;&#10;using namespace std;&#10;&#10;template&lt;typename T, typename = void_t&lt;&gt;&gt;&#10;struct is_iterable: false_type {};&#10;template&lt;typename T&gt;&#10;struct is_iterable&lt;T, void_t&lt;decltype(declval&lt;T&gt;().begin(), declval&lt;T&gt;().end())&gt;&gt;: negation&lt;is_same&lt;T, string&gt;&gt; {};&#10;&#10;template&lt;class T1, class T2&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const pair&lt;T1, T2&gt; &amp;p) {&#10;    os &lt;&lt; '(' &lt;&lt; p.first &lt;&lt; ',' &lt;&lt; p.second &lt;&lt; ')';&#10;    return os;&#10;}&#10;template&lt;class T&gt;&#10;enable_if_t&lt;is_iterable&lt;T&gt;::value, ostream&gt; &amp;operator&lt;&lt;(ostream &amp;os, const T &amp;r) {&#10;    os &lt;&lt; '[';&#10;    for (const auto &amp;e : r) os &lt;&lt; e &lt;&lt; (&amp;e != &amp;*(--r.end()) ? &quot; &quot; : &quot;&quot;);&#10;    os &lt;&lt; ']';&#10;    return os;&#10;}&#10;&#10;template&lt;class T&gt;&#10;void dump(const char *str, T &amp;&amp;h) { cerr &lt;&lt; str &lt;&lt; &quot; = &quot; &lt;&lt; h &lt;&lt; &quot;\n&quot;; };&#10;template&lt;class Head, class... Tail&gt;&#10;void dump(const char *str, Head &amp;&amp;h, Tail &amp;&amp;... t) {&#10;    while (*str != ',') cerr &lt;&lt; *str++;&#10;    cerr &lt;&lt; &quot; = &quot; &lt;&lt; h &lt;&lt; &quot;\n&quot;;&#10;    dump(str + (*(str + 1) == ' ' ? 2 : 1), t...);&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template>