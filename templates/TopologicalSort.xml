<template name="mytopologicalsort" value="class TopologicalSort {&#10;public:&#10;    explicit TopologicalSort(int n) : V(n), edges(n), used(n) {}&#10;    explicit TopologicalSort(vector&lt;vector&lt;int&gt;&gt; &amp;edges) : V(edges.size()), used(edges.size()) { this-&gt;edges = edges; }&#10;&#10;    void add_edge(int from, int to) { edges[from].emplace_back(to); }&#10;&#10;    vector&lt;int&gt; build() {&#10;&#10;        vector&lt;int&gt; res, in(V);&#10;        for (int i = 0; i &lt; V; i++) for (const auto &amp;e : edges[i]) in[e]++;&#10;&#10;        res.reserve(V);&#10;        queue&lt;int&gt; que;&#10;        for (int i = 0; i &lt; V; i++) {&#10;            if (in[i] == 0 &amp;&amp; !used[i]) {&#10;                used[i] = 1;&#10;                que.emplace(i);&#10;            }&#10;        }&#10;        while (!que.empty()) {&#10;            int now = que.front();&#10;            que.pop();&#10;            res.emplace_back(now);&#10;            for (const auto &amp;e : edges[now]) {&#10;                in[e]--;&#10;                if (in[e] == 0) {&#10;                    if (used[e]) return vector&lt;int&gt;(); // unable to sort&#10;                    used[e] = used[now] + 1;&#10;                    que.emplace(e);&#10;                }&#10;            }&#10;        }&#10;&#10;        return res;&#10;    }&#10;&#10;    [[nodiscard]] int longest_path() {&#10;        if (none_of(used.begin(), used.end(), [](int u) { return u &gt; 0; })) build();&#10;        return *max_element(used.begin(), used.end()) - 1;&#10;    }&#10;&#10;private:&#10;    int V;&#10;    vector&lt;vector&lt;int&gt;&gt; edges;&#10;    vector&lt;int&gt; used;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template>