<template name="mybellmanford" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;&#10;template&lt;class T&gt;&#10;struct Edge {&#10;    int from{}, to{};&#10;    T cost;&#10;    Edge() = default;&#10;    Edge(int to, T cost) : to(to), cost(move(cost)) {}&#10;    Edge(int from, int to, T cost) : from(from), to(to), cost(move(cost)) {}&#10;    bool operator&gt;(const Edge &amp;r) const { return this-&gt;cost &gt; r.cost; }&#10;};&#10;&#10;template&lt;class T&gt;&#10;vector&lt;T&gt; BellmanFord(const vector&lt;Edge&lt;T&gt;&gt; &amp;edges, const int V, const int st) {&#10;&#10;    const T inf = numeric_limits&lt;T&gt;::max() / 2;&#10;    vector&lt;T&gt; cost(V, inf);&#10;    cost[st] = 0;&#10;    for (int i = 0; i &lt; V - 1; i++) {&#10;        for (const auto &amp;e : edges) {&#10;            if (cost[e.from] == inf) continue;&#10;            chmin(cost[e.to], cost[e.from] + e.cost);&#10;        }&#10;    }&#10;&#10;    for (int i = 0; i &lt; V; i++) {&#10;        for (const auto &amp;e : edges) { // finding negative loop&#10;            if (cost[e.from] == inf) continue;&#10;            if (cost[e.from] == -inf) cost[e.to] = -inf; // src is nloop -&gt; dst is nloop&#10;            else if (cost[e.to] &gt; cost[e.from] + e.cost) cost[e.to] = -inf; // chmin is possible -&gt; nloop&#10;        }&#10;    }&#10;&#10;    return cost;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template>