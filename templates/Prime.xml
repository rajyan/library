<template name="myprime" value="// #define RUNTIME_MODINT&#10;&#10;#ifdef RUNTIME_MODINT&#10;template&lt;int &amp;Modulo&gt;&#10;#else&#10;template&lt;int Modulo&gt;&#10;#endif&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a = r.val, b = Modulo, u = 1, v = 0;&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            swap(a, b);&#10;            u -= t * v;&#10;            swap(u, v);&#10;        }&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return val ? Modulo - val : 0; }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp;&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res = 1, tmp = val;&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;#ifdef RUNTIME_MODINT&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;#else&#10;using mint = Mint&lt;MOD&gt;;&#10;#endif&#10;&#10;inline int ctz(lint n) {&#10;    return popcount(~n &amp; (n - 1));&#10;}#include &lt;vector&gt;&#10;&#10;#define RUNTIME_MODINT&#10;&#10;class Prime {&#10;    vector&lt;int&gt; min_pf; // min_pf[i] = minimum prime factor of i&#10;    // linear sieve https://cp-algorithms.com/algebra/prime-sieve-linear.html&#10;    void lsieve(int N) {&#10;        min_pf[0] = min_pf[1] = -1;&#10;        for (int i = 2; i &lt; N; i++) {&#10;            if (min_pf[i] == 0) {&#10;                prime.emplace_back(i);&#10;                min_pf[i] = i;&#10;            }&#10;            for (int j : prime) {&#10;                if (j &gt; min_pf[i] || i * j &gt;= N) break;&#10;                min_pf[i * j] = j;&#10;            }&#10;        }&#10;    }&#10;&#10;    void Eratosthenes(lint N) {&#10;        for (lint i = 2; i * i &lt; N; i++) {&#10;            if (pTable[i]) {&#10;                prime.emplace_back(i);&#10;                for (int j = 0; i * (j + 2) &lt; N; j++) pTable[i * (j + 2)] = false;&#10;            }&#10;        }&#10;    }&#10;&#10;public:&#10;    vector&lt;bool&gt; pTable;&#10;    vector&lt;int&gt; prime;&#10;&#10;    explicit Prime(int N, bool useLinear) : min_pf(N + 1) { lsieve(N + 1); }&#10;    explicit Prime(int N = 1100000) : pTable(N + 1, true) { Eratosthenes(N + 1); }&#10;&#10;    [[nodiscard]] vector&lt;pair&lt;lint, int&gt;&gt; factorize(lint n) {&#10;        vector&lt;pair&lt;lint, int&gt;&gt; res;&#10;        for (lint i = 2; i * i &lt;= n; i++) {&#10;            int cnt = 0;&#10;            while (n % i == 0) {&#10;                cnt++;&#10;                n /= i;&#10;            }&#10;            if (cnt) res.emplace_back(i, cnt);&#10;        }&#10;        if (n != 1) res.emplace_back(n, 1);&#10;&#10;        return res;&#10;    }&#10;&#10;    // Miller-Rabin&#10;    [[nodiscard]] bool isPrime(lint n) {&#10;        if (n &lt;= 1 || n % 2 == 0) return (n == 2);&#10;        const int s = ctz(n - 1);&#10;        const lint d = (n - 1) &gt;&gt; s;&#10;        // set runtime mod&#10;        RMOD = n;&#10;        // http://miller-rabin.appspot.com/&#10;        for (const lint base : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {&#10;            rmint a = rmint(base).pow(d);&#10;            int i = s;&#10;            while (a != 1 &amp;&amp; a != -1 &amp;&amp; a != 0 &amp;&amp; i--) a *= a;&#10;            if (a != -1 &amp;&amp; i != s) return false;&#10;        }&#10;        return true;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template>