<template name="myprime" value="template&lt;const int &amp;Modulo&gt;&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a{r.val}, b{Modulo}, u{1}, v{0};&#10;        assert(gcd(a, b) == 1 &amp;&amp; &quot;a and b must be co-prime&quot;);&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            a ^= b, b ^= a, a ^= b;&#10;            u -= t * v;&#10;            u ^= v, v ^= u, u ^= v;&#10;        }&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return Mint(-val); }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    constexpr friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    constexpr friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp{};&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res{1}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;constexpr int MOD = 1000000007;&#10;using mint = Mint&lt;MOD&gt;;&#10;&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;&#10;inline int ctz(lint n) {&#10;    return popcount(~n &amp; (n - 1));&#10;}#pragma once&#10;&#10;#define RUNTIME_MODINT&#10;&#10;class Prime {&#10;public:&#10;    vector&lt;bool&gt; pTable;&#10;    explicit Prime(int N = 1100000) : pTable(N + 1, true) { Eratosthenes(N + 1); }&#10;&#10;    [[nodiscard]] vector&lt;pair&lt;lint, int&gt;&gt; factorize(lint n) {&#10;        vector&lt;pair&lt;lint, int&gt;&gt; res;&#10;        for (lint i = 2; i * i &lt;= n; i++) {&#10;            int cnt = 0;&#10;            while (n % i == 0) {&#10;                cnt++;&#10;                n /= i;&#10;            }&#10;            if (cnt) res.emplace_back(i, cnt);&#10;        }&#10;        if (n != 1) res.emplace_back(n, 1);&#10;&#10;        return res;&#10;    }&#10;&#10;    // Miller-Rabin&#10;    [[nodiscard]] bool isPrime(lint n) {&#10;        if (n &lt;= 1 || n % 2 == 0) return (n == 2);&#10;        const int s = ctz(n - 1);&#10;        const lint d = (n - 1) &gt;&gt; s;&#10;        // set runtime mod&#10;        RMOD = n;&#10;        // http://miller-rabin.appspot.com/&#10;        for (const lint base : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {&#10;            rmint a = rmint(base).pow(d);&#10;            int i = s;&#10;            while (a != 1 &amp;&amp; a != -1 &amp;&amp; a != 0 &amp;&amp; i--) a *= a;&#10;            if (a != -1 &amp;&amp; i != s) return false;&#10;        }&#10;        return true;&#10;    }&#10;private:&#10;    void Eratosthenes(lint N) {&#10;        for (lint i = 2; i * i &lt; N; i++) {&#10;            if (pTable[i]) {&#10;                for (int j = 0; i * (j + 2) &lt; N; j++) pTable[i * (j + 2)] = false;&#10;            }&#10;        }&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template>