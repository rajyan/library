<template name="mysegmenttree" value="template&lt;class T, T (*F)(T, T), const T(*e) = nullptr&gt;&#10;class Monoid {&#10;    class Identity {};&#10;    constexpr static auto has_identity = (e != nullptr);&#10;public:&#10;    using type = T;&#10;    using vt = conditional_t&lt;has_identity, T, variant&lt;Identity, T&gt;&gt;;&#10;&#10;    [[nodiscard]] constexpr vt op(const vt &amp;a, const vt &amp;b) const {&#10;        if constexpr (has_identity) return F(a, b);&#10;        else if (a.index() == 1 &amp;&amp; b.index() == 1) return F(get&lt;T&gt;(a), get&lt;T&gt;(b));&#10;        else if (a.index() == 0) return b;&#10;        else return a;&#10;    };&#10;    [[nodiscard]] constexpr vt identity() const {&#10;        if constexpr (has_identity) return *e;&#10;        else return Identity{};&#10;    }&#10;};&#10;&#10;namespace monoid {&#10;    constexpr auto op_add = [](auto l, auto r) { return l + r; };&#10;    constexpr auto op_mul = [](auto l, auto r) { return l * r; };&#10;    constexpr auto op_max = [](auto l, auto r) { return max(l, r); };&#10;    constexpr auto op_min = [](auto l, auto r) { return min(l, r); };&#10;    template&lt;class T&gt; T e_add = T{};&#10;    template&lt;class T&gt; T e_mul = T{1};&#10;    template&lt;class T&gt; T e_max = numeric_limits&lt;T&gt;::max();&#10;    template&lt;class T&gt; T e_min = numeric_limits&lt;T&gt;::min();&#10;    template&lt;class T&gt; using add = Monoid&lt;T, monoid::op_add, &amp;monoid::e_add&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using mul = Monoid&lt;T, monoid::op_mul, &amp;monoid::e_mul&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using max = Monoid&lt;T, monoid::op_max, &amp;monoid::e_max&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using min = Monoid&lt;T, monoid::op_min, &amp;monoid::e_min&lt;T&gt;&gt;;&#10;}#pragma once&#10;&#10;inline int clz(lint x) {&#10;    union {&#10;        unsigned long long as_uint64;&#10;        double as_double;&#10;    } data{};&#10;    data.as_double = (double)x + 0.5;&#10;    int n = 1054 - (int)(data.as_uint64 &gt;&gt; 52);&#10;    return 32 + n;&#10;}&#10;&#10;template&lt;class M&gt;&#10;class SegmentTree {&#10;    using T = typename M::type;&#10;    using vt = typename M::vt;&#10;public:&#10;    explicit SegmentTree(const int &amp;n_)&#10;            : n(n_), lg(64 - clz(n)), sz(1 &lt;&lt; lg),&#10;              d(2 * sz, m.identity()) {&#10;    }&#10;    explicit SegmentTree(const vector&lt;T&gt; &amp;v)&#10;            : n((int)v.size()), lg(64 - clz(n)), sz(1 &lt;&lt; lg),&#10;              d(2 * sz, m.identity()) {&#10;        for (int i = 0; i &lt; n; i++) d[sz + i] = v[i];&#10;        for (int i = sz - 1; i &gt;= 0; i--) update(i);&#10;    }&#10;&#10;    void set(int k, const vt &amp;x) {&#10;        assert(0 &lt;= k &amp;&amp; k &lt; n);&#10;        k += sz, d[k] = x;&#10;        for (int i = 1; i &lt;= lg; i++) update(k &gt;&gt; i);&#10;    }&#10;    void add(const int &amp;k, const vt &amp;x) { set(k, m.op(d[k + sz], x)); }&#10;&#10;    [[nodiscard]] vt sum(int l, int r) const {&#10;        assert(l &lt;= r);&#10;        vt sml = m.identity(), smr = m.identity();&#10;        l += sz, r += sz;&#10;&#10;        while (l &lt; r) {&#10;            if (l &amp; 1) sml = m.op(sml, d[l++]);&#10;            if (r &amp; 1) smr = m.op(d[--r], smr);&#10;            l &gt;&gt;= 1;&#10;            r &gt;&gt;= 1;&#10;        }&#10;        return m.op(sml, smr);&#10;    }&#10;    [[nodiscard]] vt operator[](const int &amp;k) const {&#10;        assert(0 &lt;= k &amp;&amp; k &lt; n);&#10;        return d[k + sz];&#10;    }&#10;&#10;private:&#10;    M m;&#10;    int n, lg, sz;&#10;    vector&lt;vt&gt; d;&#10;    void update(const int &amp;k) { d[k] = m.op(d[2 * k], d[2 * k + 1]); }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template>