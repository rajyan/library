<template name="mylowestcommonancestor" value="class LCA {&#10;private:&#10;&#10;    int N, lg_N;&#10;    vector&lt;int&gt; depth;&#10;    vector&lt;vector&lt;int&gt;&gt; par;&#10;&#10;    void build(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, int root) {&#10;&#10;        auto dfs = [&amp;](auto &amp;&amp;f, int now) -&gt; void {&#10;            for (const auto &amp;next : tree[now]) {&#10;                if (par[0][next] == -1) {&#10;                    par[0][next] = now;&#10;                    depth[next] = depth[now] + 1;&#10;                    f(f, next);&#10;                }&#10;            }&#10;        };&#10;&#10;        par[0][root] = root;&#10;        dfs(dfs, root);&#10;&#10;        for (int bit = 0; bit &lt; lg_N; bit++) {&#10;            for (int i = 0; i &lt; N; i++) {&#10;                par[bit + 1][i] = par[bit][par[bit][i]];&#10;            }&#10;        }&#10;    }&#10;&#10;    int ancestor(int now, int n) {&#10;        if (n &lt;= 0) return now;&#10;        for (int i = 0, lg_n = 32 - nlz(n); i &lt; lg_n; i++) {&#10;            if (n &amp; (1LL &lt;&lt; i)) now = par[i][now];&#10;        }&#10;        return now;&#10;    }&#10;&#10;    static int nlz(unsigned int x) {&#10;        union {&#10;            unsigned int as_uint32;&#10;            float as_float;&#10;        } data{};&#10;        data.as_float = (float)x + 0.5;&#10;        int n = 158 - (data.as_uint32 &gt;&gt; 23);&#10;        return n;&#10;    }&#10;&#10;public:&#10;    explicit LCA(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, int root = 0) : N(tree.size()), lg_N(32 - nlz(N)), depth(N),&#10;                                                          par(lg_N + 1, vector&lt;int&gt;(N, -1)) { build(tree, root); }&#10;&#10;    int get_lca(int u, int v) {&#10;&#10;        if (depth[u] &lt; depth[v]) swap(u, v);&#10;        u = ancestor(u, depth[u] - depth[v]);&#10;        if (u == v) return u;&#10;&#10;        for (int i = 32 - nlz(depth[u]); i &gt;= 0; i--) {&#10;            if (par[i][u] != par[i][v]) {&#10;                u = par[i][u];&#10;                v = par[i][v];&#10;            }&#10;        }&#10;        return par[0][u];&#10;    }&#10;&#10;    int dist(int u, int v) {&#10;        return depth[u] + depth[v] - 2 * depth[get_lca(u, v)];&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template>