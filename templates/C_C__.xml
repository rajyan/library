<templateSet group="C/C++"><template name="mybellmanford" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;template&lt;class T&gt;&#10;struct Edge {&#10;    int from{}, to{};&#10;    T cost;&#10;    Edge() = default;&#10;    Edge(int to, T cost) : to(to), cost(cost) {}&#10;    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}&#10;    bool operator&gt;(const Edge &amp;r) const { return this-&gt;cost &gt; r.cost; }&#10;};&#10;&#10;template&lt;class T&gt;&#10;vector&lt;T&gt; BellmanFord(const vector&lt;Edge&lt;T&gt;&gt; &amp;edges, const int V, const int st) {&#10;&#10;    const T inf = numeric_limits&lt;T&gt;::max() / 2;&#10;    vector&lt;T&gt; cost(V, inf);&#10;    cost[st] = 0;&#10;    for (int i = 0; i &lt; V - 1; i++) {&#10;        for (const auto &amp;e : edges) {&#10;            if (cost[e.from] == inf) continue;&#10;            chmin(cost[e.to], cost[e.from] + e.cost);&#10;        }&#10;    }&#10;&#10;    for (int i = 0; i &lt; V; i++) {&#10;        for (const auto &amp;e : edges) { // finding negative loop&#10;            if (cost[e.from] == inf) continue;&#10;            if (cost[e.from] == -inf) cost[e.to] = -inf; // src is nloop -&gt; dst is nloop&#10;            else if (cost[e.to] &gt; cost[e.from] + e.cost) cost[e.to] = -inf; // chmin is possible -&gt; nloop&#10;        }&#10;    }&#10;&#10;    return cost;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mybisearch" value="auto judge = [&amp;](auto key) {&#10;    return key;&#10;};&#10;&#10;auto bisearch = [&amp;](auto f) {&#10;&#10;    auto ng = -1LL;&#10;    auto ok = LINF;&#10;&#10;    while (abs(ok - ng) &gt; 1) {&#10;        auto mid = (ok + ng) / 2;&#10;&#10;        if (f(mid)) ok = mid;&#10;        else ng = mid;&#10;    }&#10;&#10;    return ok;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mychmax" value="template&lt;class T&gt;&#10;inline bool chmax(T &amp;a, const T b) { return a &lt; b &amp;&amp; (a = b, true); }&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mychmin" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myclz" value="inline int clz(lint x) {&#10;    union {&#10;        unsigned long long as_uint64;&#10;        double as_double;&#10;    } data{};&#10;    data.as_double = (double)x + 0.5;&#10;    int n = 1054 - (int)(data.as_uint64 &gt;&gt; 52);&#10;    return 32 + n;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mycombination" value="template&lt;int Modulo = MOD&gt;&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a = r.val, b = Modulo, u = 1, v = 0;&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            swap(a, b);&#10;            u -= t * v;&#10;            swap(u, v);&#10;        }&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return val ? Modulo - val : 0; }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp;&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res = 1, tmp = val;&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;using mint = Mint&lt;&gt;;&#10;&#10;template&lt;class T = mint&gt;&#10;class Combination {&#10;private:&#10;    vector&lt;T&gt; fac, inv, finv;&#10;&#10;    void build(int N) {&#10;        fac[0] = fac[1] = 1;&#10;        inv[1] = 1;&#10;        finv[0] = finv[1] = 1;&#10;&#10;        for (int i = 2; i &lt; N; i++) {&#10;            fac[i] = fac[i - 1] * i;&#10;            inv[i] = -inv[MOD % i] * (MOD / i);&#10;            finv[i] = finv[i - 1] * inv[i];&#10;        }&#10;    }&#10;&#10;public:&#10;    explicit Combination(int N = 110000) : fac(N + 1), inv(N + 1), finv(N + 1) { build(N + 1); }&#10;&#10;    T operator()(int n, int k) {&#10;        if (n &lt; k || k &lt; 0) return 0LL;&#10;        return fac[n] * (finv[k] * finv[n - k]);&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mycompress" value="template&lt;class T&gt;&#10;class Compress {&#10;private:&#10;    vector&lt;T&gt; comp{};&#10;&#10;public:&#10;    Compress() = default;&#10;    explicit Compress(const vector&lt;T&gt; &amp;vec) : comp(vec) { build(); }&#10;&#10;    void add(const T &amp;x) { comp.emplace_back(x); }&#10;&#10;    void build() {&#10;        sort(begin(comp), end(comp));&#10;        comp.erase(unique(begin(comp), end(comp)), end(comp));&#10;    }&#10;&#10;    [[nodiscard]] vector&lt;int&gt; get(const vector&lt;T&gt; &amp;vec) const {&#10;        vector&lt;int&gt; ret(vec.size());&#10;        transform(vec.begin(), vec.end(), ret.begin(), [&amp;](const T &amp;x) { return get(x); });&#10;        return ret;&#10;    }&#10;    [[nodiscard]] int get(const T &amp;x) const { return lower_bound(comp.begin(), comp.end(), x) - begin(comp); }&#10;&#10;    const T &amp;operator[](const int k) const { return comp[k]; }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myctz" value="inline int popcount(lint n) {&#10;    n = (n &amp; 0x5555555555555555) + (n &gt;&gt; 1 &amp; 0x5555555555555555);&#10;    n = (n &amp; 0x3333333333333333) + (n &gt;&gt; 2 &amp; 0x3333333333333333);&#10;    n = (n &amp; 0x0f0f0f0f0f0f0f0f) + (n &gt;&gt; 4 &amp; 0x0f0f0f0f0f0f0f0f);&#10;    n = (n &amp; 0x00ff00ff00ff00ff) + (n &gt;&gt; 8 &amp; 0x00ff00ff00ff00ff);&#10;    n = (n &amp; 0x0000ffff0000ffff) + (n &gt;&gt; 16 &amp; 0x0000ffff0000ffff);&#10;    n = (n &amp; 0x00000000ffffffff) + (n &gt;&gt; 32 &amp; 0x00000000ffffffff);&#10;    return n;&#10;}&#10;&#10;inline int ctz(lint n) {&#10;    return popcount(~n &amp; (n - 1));&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mycumulativesum" value="template&lt;class T&gt;&#10;class CuSum {&#10;private:&#10;    vector&lt;T&gt; cusum;&#10;&#10;public:&#10;    explicit CuSum(vector&lt;T&gt; const &amp;vec) : cusum(vec.size() + 1) {&#10;        for (int i = 0; i &lt; (int)vec.size(); i++) cusum[i + 1] = cusum[i] + vec[i];&#10;    }&#10;    explicit CuSum(const int N) : cusum(N + 1) {}&#10;    void add(const int i, const T &amp;x) { cusum[i + 1] += x; }&#10;    void build() { for (int i = 0; i &lt; (int)cusum.size() - 1; i++) cusum[i + 1] += cusum[i]; }&#10;&#10;    // partial sum of 0-indexed [l, r)&#10;    T operator()(int l, int r) {&#10;        if (r &lt; l || r &lt; 0) {&#10;            assert(0);&#10;            return T{};&#10;        }&#10;        else return cusum[r] - cusum[l];&#10;    }&#10;    // 0-indexed&#10;    const T &amp;operator[](int i) { return cusum[i + 1]; }&#10;    T back() { return cusum.back(); }&#10;};&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mydebugtemplate" value="#pragma once&#10;&#10;#define _CRT_SECURE_NO_WARNINGS&#10;&#10;#include &lt;iostream&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;set&gt;&#10;#include &lt;map&gt;&#10;&#10;using namespace std;&#10;&#10;template&lt;class T&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;vec) {&#10;    os &lt;&lt; &quot;[ &quot;;&#10;    for (const auto &amp;e : vec) os &lt;&lt; e &lt;&lt; &quot; &quot;;&#10;    os &lt;&lt; &quot;]\n&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;class T&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const set &lt;T&gt; &amp;st) {&#10;    os &lt;&lt; &quot;[ &quot;;&#10;    for (const auto &amp;e : st) os &lt;&lt; e &lt;&lt; &quot; &quot;;&#10;    os &lt;&lt; &quot;]\n&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;class T1, class T2&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const pair &lt;T1, T2&gt; &amp;p) {&#10;    os &lt;&lt; '(' &lt;&lt; p.first &lt;&lt; ',' &lt;&lt; p.second &lt;&lt; ')';&#10;    return os;&#10;}&#10;&#10;template&lt;class T1, class T2&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const map &lt;T1, T2&gt; &amp;mp) {&#10;    os &lt;&lt; &quot;[ &quot;;&#10;    for (const auto &amp;e : mp) os &lt;&lt; e &lt;&lt; &quot; &quot;;&#10;    os &lt;&lt; &quot;]\n&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;class T&gt;&#10;void dump(const char *str, T &amp;&amp;h) { cerr &lt;&lt; str &lt;&lt; &quot; = &quot; &lt;&lt; h &lt;&lt; &quot;\n&quot;; };&#10;template&lt;class Head, class... Tail&gt;&#10;void dump(const char *str, Head &amp;&amp;h, Tail &amp;&amp;... t) {&#10;    while (*str != ',') cerr &lt;&lt; *str++;&#10;    cerr &lt;&lt; &quot; = &quot; &lt;&lt; h &lt;&lt; &quot;\n&quot;;&#10;    dump(str + (*(str + 1) == ' ' ? 2 : 1), t...);&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mydijkstra" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;template&lt;class T&gt;&#10;struct Edge {&#10;    int from{}, to{};&#10;    T cost;&#10;    Edge() = default;&#10;    Edge(int to, T cost) : to(to), cost(cost) {}&#10;    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}&#10;    bool operator&gt;(const Edge &amp;r) const { return this-&gt;cost &gt; r.cost; }&#10;};&#10;&#10;template&lt;class T&gt;&#10;vector&lt;T&gt; Dijkstra(const vector&lt;vector&lt;Edge&lt;T&gt;&gt;&gt; &amp;edges, const int st) {&#10;&#10;    const int V = (int)edges.size();&#10;    const T inf = numeric_limits&lt;T&gt;::max() / 2;&#10;    vector&lt;T&gt; cost(V, inf);&#10;    cost[st] = 0;&#10;&#10;    priority_queue &lt;Edge&lt;T&gt;, vector&lt;Edge&lt;T&gt;&gt;, greater&lt;Edge&lt;T&gt;&gt;&gt; pq;&#10;    pq.emplace(st, cost[st]);&#10;&#10;    while (!pq.empty()) {&#10;&#10;        Edge&lt;T&gt; now(pq.top().to, pq.top().cost);&#10;        pq.pop();&#10;&#10;        if (cost[now.to] &lt; now.cost) continue;&#10;        for (const Edge&lt;T&gt; &amp;e : edges[now.to]) {&#10;            T tmp_cost = now.cost + e.cost;&#10;            if (chmin(cost[e.to], tmp_cost)) {&#10;                pq.emplace(e.to, cost[e.to]);&#10;            }&#10;        }&#10;    }&#10;&#10;    return cost; // min cost to vertex idx from st&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mydivisor" value="template&lt;class T&gt;&#10;vector&lt;T&gt; divisor(const T n) {&#10;    vector&lt;T&gt; res;&#10;    for (T i = 1; i * i &lt;= n; i++) {&#10;        if (n % i == 0) {&#10;            res.emplace_back(i);&#10;            if (i * i != n) res.emplace_back(n / i);&#10;        }&#10;    }&#10;    sort(res.begin(), res.end());&#10;    return res;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myedge" value="template&lt;class T&gt;&#10;struct Edge {&#10;    int from{}, to{};&#10;    T cost;&#10;    Edge() = default;&#10;    Edge(int to, T cost) : to(to), cost(cost) {}&#10;    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}&#10;    bool operator&gt;(const Edge &amp;r) const { return this-&gt;cost &gt; r.cost; }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myfactorial" value="class Factorial {&#10;private:&#10;    vector&lt;lint&gt; fac, inv, finv;&#10;&#10;    void build(int N) {&#10;        fac[0] = fac[1] = 1;&#10;        inv[1] = 1;&#10;        finv[0] = finv[1] = 1;&#10;&#10;        for (int i = 2; i &lt; N; i++) {&#10;            fac[i] = fac[i - 1] * i % MOD;&#10;            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;&#10;            finv[i] = finv[i - 1] * inv[i] % MOD;&#10;        }&#10;    }&#10;&#10;public:&#10;    explicit Factorial(int N = 110000) : fac(N + 1), inv(N + 1), finv(N + 1) { build(N + 1); }&#10;&#10;    [[nodiscard]] lint Cmod(int n, int k) {&#10;        if (n &lt; k || k &lt; 0) return 0LL;&#10;        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;&#10;    }&#10;&#10;    [[nodiscard]] lint Pmod(int n, int k) {&#10;        if (n &lt; k || k &lt; 0) return 0LL;&#10;        return fac[n] * finv[n - k] % MOD;&#10;    }&#10;&#10;    [[nodiscard]] lint Hmod(int n, int k) {&#10;        if (n &lt; 0 || k &lt; 0) return 0LL;&#10;        return k == 0 ? 1 : Cmod(n + k - 1, k);&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myfenwicktree" value="template&lt;class T&gt;&#10;class FenwickTree {&#10;private:&#10;    int n;&#10;    vector&lt;T&gt; bit;&#10;public:&#10;    explicit FenwickTree(int sz, T &amp;&amp;x = T{}) : n(sz), bit(n + 1) {&#10;        for (int i = 0; i &lt; n; i++) add(i, x);&#10;    }&#10;&#10;    [[nodiscard]] T sum(int k) const {&#10;        T res = 0;&#10;        for (k--; k &gt;= 0; k = (k &amp; (k + 1)) - 1) res += bit[k];&#10;        return res;&#10;    }&#10;    [[nodiscard]] T sum(int l, int r) const { return sum(r) - sum(l); }&#10;&#10;    void add(int k, const T &amp;x) {&#10;        for (; k &lt; n; k |= k + 1) bit[k] += x;&#10;    }&#10;    void set(int k, const T &amp;x) { add(k, x - sum(k, k + 1)); }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myfloydwarshall" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;&#10;template&lt;class T&gt;&#10;vector&lt;vector&lt;T&gt;&gt; FloydWarshall(const vector&lt;vector&lt;T&gt;&gt; &amp;in, const T diag = T{}) {&#10;&#10;    const int N = in.size();&#10;    assert(N == (int)in[0].size());&#10;    const T inf = in[0][0];&#10;&#10;    auto d = in;&#10;    for (int i = 0; i &lt; N; i++) d[i][i] = diag;&#10;    for (int k = 0; k &lt; N; k++) {&#10;        for (int i = 0; i &lt; N; i++) {&#10;            for (int j = 0; j &lt; N; j++) {&#10;                if (d[i][k] &lt; inf &amp;&amp; d[k][j] &lt; inf) chmin(d[i][j], d[i][k] + d[k][j]);&#10;            }&#10;        }&#10;    }&#10;    return d;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myfnv1a" value="inline uint64_t fnv1a_64(const string&amp; data) {&#10;&#10;    uint64_t hash = 0xcbf29ce484222325;&#10;    constexpr uint64_t prime = 0x100000001b3;&#10;&#10;    for (char i : data) {&#10;        hash = hash ^ i;&#10;        hash *= prime;&#10;    }&#10;&#10;    return hash;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mylowestcommonancestor" value="inline int clz(lint x) {&#10;    union {&#10;        unsigned long long as_uint64;&#10;        double as_double;&#10;    } data{};&#10;    data.as_double = (double)x + 0.5;&#10;    int n = 1054 - (int)(data.as_uint64 &gt;&gt; 52);&#10;    return 32 + n;&#10;}&#10;&#10;class LCA {&#10;private:&#10;&#10;    int N, lg_N;&#10;    vector&lt;int&gt; depth;&#10;    vector&lt;vector&lt;int&gt;&gt; par;&#10;&#10;    void build(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, int root) {&#10;&#10;        auto dfs = [&amp;](auto &amp;&amp;f, int now) -&gt; void {&#10;            for (const auto &amp;next : tree[now]) {&#10;                if (par[0][next] == -1) {&#10;                    par[0][next] = now;&#10;                    depth[next] = depth[now] + 1;&#10;                    f(f, next);&#10;                }&#10;            }&#10;        };&#10;&#10;        par[0][root] = root;&#10;        dfs(dfs, root);&#10;&#10;        for (int bit = 0; bit &lt; lg_N; bit++) {&#10;            for (int i = 0; i &lt; N; i++) {&#10;                par[bit + 1][i] = par[bit][par[bit][i]];&#10;            }&#10;        }&#10;    }&#10;&#10;    [[nodiscard]] int ancestor(int now, int n) {&#10;        if (n &lt;= 0) return now;&#10;        for (int i = 0, lg_n = 64 - clz(n); i &lt; lg_n; i++) {&#10;            if (n &amp; (1LL &lt;&lt; i)) now = par[i][now];&#10;        }&#10;        return now;&#10;    }&#10;&#10;public:&#10;    explicit LCA(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, int root = 0) : N(tree.size()), lg_N(64 - clz(N)), depth(N),&#10;                                                                  par(lg_N + 1, vector&lt;int&gt;(N, -1)) { build(tree, root); }&#10;&#10;    int get_lca(int u, int v) {&#10;&#10;        if (depth[u] &lt; depth[v]) swap(u, v);&#10;        u = ancestor(u, depth[u] - depth[v]);&#10;        if (u == v) return u;&#10;&#10;        for (int i = 64 - clz(depth[u]); i &gt;= 0; i--) {&#10;            if (par[i][u] != par[i][v]) {&#10;                u = par[i][u];&#10;                v = par[i][v];&#10;            }&#10;        }&#10;        return par[0][u];&#10;    }&#10;&#10;    int dist(int u, int v) {&#10;        return depth[u] + depth[v] - 2 * depth[get_lca(u, v)];&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mymakevec" value="template&lt;class T&gt;&#10;vector&lt;T&gt; make_vec(size_t s, T val) { return vector&lt;T&gt;(s, val); }&#10;template&lt;class... Size&gt;&#10;auto make_vec(size_t s, Size... tail) {&#10;    return vector&lt;decltype(make_vec(tail...))&gt;(s, make_vec(tail...));&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mymatrix2d" value="template&lt;class T&gt;&#10;struct Point2D {&#10;    T x{}, y{};&#10;&#10;    constexpr Point2D() = default;&#10;    constexpr Point2D(T x, T y) noexcept: x(x), y(y) {};&#10;    constexpr explicit Point2D(pair&lt;T, T&gt; &amp;p) noexcept: x(p.first), y(p.second) {};&#10;&#10;    constexpr bool operator==(const Point2D &amp;rhs) const noexcept { return x == rhs.x &amp;&amp; y == rhs.y; }&#10;    constexpr bool operator!=(const Point2D &amp;rhs) const noexcept { return !(*this == rhs); }&#10;    constexpr bool operator&lt;(const Point2D &amp;rhs) const noexcept { return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); }&#10;    constexpr bool operator&gt;(const Point2D &amp;rhs) const noexcept { return rhs &lt; *this; }&#10;    constexpr bool operator&lt;=(const Point2D &amp;rhs) const noexcept { return !(*this &gt; rhs); }&#10;    constexpr bool operator&gt;=(const Point2D &amp;rhs) const noexcept { return !(*this &lt; rhs); }&#10;&#10;    constexpr Point2D operator+(const Point2D &amp;rhs) const noexcept { return {x + rhs.x, y + rhs.y}; }&#10;    constexpr Point2D operator-(const Point2D &amp;rhs) const noexcept { return {x - rhs.x, y - rhs.y}; }&#10;    constexpr Point2D operator*(const T &amp;k) const noexcept { return {k * x, k * y}; }&#10;    constexpr Point2D operator/(const T &amp;k) const noexcept { return {x / k, y / k}; }&#10;    constexpr Point2D &amp;operator+=(const Point2D &amp;rhs) noexcept { return *this = *this + rhs; }&#10;    constexpr Point2D &amp;operator-=(const Point2D &amp;rhs) noexcept { return *this = *this - rhs; }&#10;    constexpr Point2D &amp;operator*=(const T &amp;k) noexcept { return *this = *this * k; }&#10;    constexpr Point2D &amp;operator/=(const T &amp;k) noexcept { return *this = *this / k; }&#10;    constexpr Point2D &amp;operator--(int) noexcept { return *this -= Point2D(1, 1); };&#10;    constexpr Point2D &amp;operator++(int) noexcept { return *this += Point2D(1, 1); };&#10;    constexpr Point2D operator-() const noexcept { return {-x, -y}; }&#10;&#10;    constexpr T operator*(const Point2D &amp;rhs) const noexcept { return x * rhs.x + y * rhs.y; }&#10;&#10;    [[nodiscard]] constexpr Point2D nor() const noexcept { return {y, -x}; }&#10;    [[nodiscard]] constexpr long double hypot() const noexcept { return ::hypotl(x, y); }&#10;    [[nodiscard]] constexpr bool inGrid(const T &amp;H, const T &amp;W) const noexcept { return 0 &lt;= x &amp;&amp; x &lt; H &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; W; }&#10;    template&lt;class U&gt;&#10;    [[nodiscard]] constexpr U &amp;operator[](vector&lt;vector&lt;U&gt;&gt; &amp;v) { return v[x][y]; }&#10;&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Point2D &amp;p) { return is &gt;&gt; p.x &gt;&gt; p.y; }&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point2D &amp;p) { return os &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y; }&#10;};&#10;&#10;using pnt = Point2D&lt;lint&gt;;&#10;&#10;template&lt;class T&gt;&#10;struct Matrix2D {&#10;    Point2D&lt;T&gt; r0{}, r1{};&#10;&#10;    constexpr Matrix2D() = default;&#10;    constexpr Matrix2D(const Point2D&lt;T&gt; &amp;r0, const Point2D&lt;T&gt; &amp;r1) noexcept: r0(r0), r1(r1) {};&#10;&#10;    constexpr bool operator==(const Matrix2D &amp;rhs) const noexcept { return r0 == rhs.r0 &amp;&amp; r1 == rhs.r1; }&#10;    constexpr bool operator!=(const Matrix2D &amp;rhs) const noexcept { return !(*this == rhs); }&#10;&#10;    constexpr Matrix2D operator+(const Matrix2D &amp;rhs) const noexcept { return {r0 + rhs.r0, r1 + rhs.r1}; }&#10;    constexpr Matrix2D operator-(const Matrix2D &amp;rhs) const noexcept { return {r0 - rhs.r0, r1 - rhs.r1}; }&#10;    constexpr Matrix2D operator*(const Matrix2D &amp;rhs) const noexcept {&#10;        const Matrix2D rhs_T = rhs.trans();&#10;        return {{r0 * rhs_T.r0, r0 * rhs_T.r1},&#10;                {r1 * rhs_T.r0, r1 * rhs_T.r1}};&#10;    }&#10;    constexpr Matrix2D &amp;operator+=(const Matrix2D &amp;rhs) noexcept { return *this = *this + rhs; }&#10;    constexpr Matrix2D &amp;operator-=(const Matrix2D &amp;rhs) noexcept { return *this = *this - rhs; }&#10;    constexpr Matrix2D &amp;operator*=(const Matrix2D &amp;rhs) noexcept { return *this = *this * rhs; }&#10;    constexpr Matrix2D operator-() noexcept { return {-r0, -r1}; }&#10;&#10;    constexpr Point2D&lt;T&gt; operator*(const Point2D&lt;T&gt; &amp;b_T) const noexcept { return {r0 * b_T, r1 * b_T}; }&#10;&#10;    [[nodiscard]] constexpr Matrix2D trans() const noexcept {&#10;        return {{r0.x, r1.x},&#10;                {r0.y, r1.y}};&#10;    }&#10;    [[nodiscard]] constexpr Matrix2D identity() const noexcept {&#10;        return {{1, 0},&#10;                {0, 1}};&#10;    }&#10;    [[nodiscard]] constexpr Matrix2D pow(lint n) const noexcept {&#10;        Matrix2D res{Matrix2D().identity()}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;    [[nodiscard]] constexpr T det() const noexcept { return r0 * r1.nor(); }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mymodint" value="#ifdef RUNTIME_MODINT&#10;template&lt;int &amp;Modulo&gt;&#10;#else&#10;template&lt;int Modulo&gt;&#10;#endif&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a{r.val}, b{Modulo}, u{1}, v{0};&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            swap(a, b);&#10;            u -= t * v;&#10;            swap(u, v);&#10;        }&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return val ? Modulo - val : 0; }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp;&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res{1}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;#ifdef RUNTIME_MODINT&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;#else&#10;using mint = Mint&lt;MOD&gt;;&#10;#endif&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mymodpow" value="lint modpow(lint a, lint n, lint mod = MOD) {&#10;    lint res = 1;&#10;    while (n &gt; 0) {&#10;        if (n &amp; 1) res = res * a % mod;&#10;        a = a * a % mod;&#10;        n &gt;&gt;= 1;&#10;    }&#10;    return res;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mypoint2d" value="template&lt;class T&gt;&#10;struct Point2D {&#10;    T x{}, y{};&#10;&#10;    constexpr Point2D() = default;&#10;    constexpr Point2D(T x, T y) noexcept: x(x), y(y) {};&#10;    constexpr explicit Point2D(pair&lt;T, T&gt; &amp;p) noexcept: x(p.first), y(p.second) {};&#10;&#10;    constexpr bool operator==(const Point2D &amp;rhs) const noexcept { return x == rhs.x &amp;&amp; y == rhs.y; }&#10;    constexpr bool operator!=(const Point2D &amp;rhs) const noexcept { return !(*this == rhs); }&#10;    constexpr bool operator&lt;(const Point2D &amp;rhs) const noexcept { return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); }&#10;    constexpr bool operator&gt;(const Point2D &amp;rhs) const noexcept { return rhs &lt; *this; }&#10;    constexpr bool operator&lt;=(const Point2D &amp;rhs) const noexcept { return !(*this &gt; rhs); }&#10;    constexpr bool operator&gt;=(const Point2D &amp;rhs) const noexcept { return !(*this &lt; rhs); }&#10;&#10;    constexpr Point2D operator+(const Point2D &amp;rhs) const noexcept { return {x + rhs.x, y + rhs.y}; }&#10;    constexpr Point2D operator-(const Point2D &amp;rhs) const noexcept { return {x - rhs.x, y - rhs.y}; }&#10;    constexpr Point2D operator*(const T &amp;k) const noexcept { return {k * x, k * y}; }&#10;    constexpr Point2D operator/(const T &amp;k) const noexcept { return {x / k, y / k}; }&#10;    constexpr Point2D &amp;operator+=(const Point2D &amp;rhs) noexcept { return *this = *this + rhs; }&#10;    constexpr Point2D &amp;operator-=(const Point2D &amp;rhs) noexcept { return *this = *this - rhs; }&#10;    constexpr Point2D &amp;operator*=(const T &amp;k) noexcept { return *this = *this * k; }&#10;    constexpr Point2D &amp;operator/=(const T &amp;k) noexcept { return *this = *this / k; }&#10;    constexpr Point2D &amp;operator--(int) noexcept { return *this -= Point2D(1, 1); };&#10;    constexpr Point2D &amp;operator++(int) noexcept { return *this += Point2D(1, 1); };&#10;    constexpr Point2D operator-() const noexcept { return {-x, -y}; }&#10;&#10;    constexpr T operator*(const Point2D &amp;rhs) const noexcept { return x * rhs.x + y * rhs.y; }&#10;&#10;    [[nodiscard]] constexpr Point2D nor() const noexcept { return {y, -x}; }&#10;    [[nodiscard]] constexpr long double hypot() const noexcept { return ::hypotl(x, y); }&#10;    [[nodiscard]] constexpr bool inGrid(const T &amp;H, const T &amp;W) const noexcept { return 0 &lt;= x &amp;&amp; x &lt; H &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; W; }&#10;    template&lt;class U&gt;&#10;    [[nodiscard]] constexpr U &amp;operator[](vector&lt;vector&lt;U&gt;&gt; &amp;v) { return v[x][y]; }&#10;&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Point2D &amp;p) { return is &gt;&gt; p.x &gt;&gt; p.y; }&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point2D &amp;p) { return os &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y; }&#10;};&#10;&#10;using pnt = Point2D&lt;lint&gt;;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mypopcount" value="inline int popcount(lint n) {&#10;    n = (n &amp; 0x5555555555555555) + (n &gt;&gt; 1 &amp; 0x5555555555555555);&#10;    n = (n &amp; 0x3333333333333333) + (n &gt;&gt; 2 &amp; 0x3333333333333333);&#10;    n = (n &amp; 0x0f0f0f0f0f0f0f0f) + (n &gt;&gt; 4 &amp; 0x0f0f0f0f0f0f0f0f);&#10;    n = (n &amp; 0x00ff00ff00ff00ff) + (n &gt;&gt; 8 &amp; 0x00ff00ff00ff00ff);&#10;    n = (n &amp; 0x0000ffff0000ffff) + (n &gt;&gt; 16 &amp; 0x0000ffff0000ffff);&#10;    n = (n &amp; 0x00000000ffffffff) + (n &gt;&gt; 32 &amp; 0x00000000ffffffff);&#10;    return n;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myprime" value="// #define RUNTIME_MODINT&#10;&#10;#ifdef RUNTIME_MODINT&#10;template&lt;int &amp;Modulo&gt;&#10;#else&#10;template&lt;int Modulo&gt;&#10;#endif&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a = r.val, b = Modulo, u = 1, v = 0;&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            swap(a, b);&#10;            u -= t * v;&#10;            swap(u, v);&#10;        }&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return val ? Modulo - val : 0; }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp;&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res = 1, tmp = val;&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;#ifdef RUNTIME_MODINT&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;#else&#10;using mint = Mint&lt;MOD&gt;;&#10;#endif&#10;&#10;inline int ctz(lint n) {&#10;    return popcount(~n &amp; (n - 1));&#10;}#include &lt;vector&gt;&#10;&#10;#define RUNTIME_MODINT&#10;&#10;class Prime {&#10;    vector&lt;int&gt; prime;&#10;    vector&lt;int&gt; min_pf; // min_pf[i] = minimum prime factor of i&#10;    // linear sieve https://cp-algorithms.com/algebra/prime-sieve-linear.html&#10;    void linearSieve(int N) {&#10;        min_pf[0] = min_pf[1] = -1;&#10;        for (int i = 2; i &lt; N; i++) {&#10;            if (min_pf[i] == 0) {&#10;                prime.emplace_back(i);&#10;                min_pf[i] = i;&#10;            }&#10;            for (int j : prime) {&#10;                if (j &gt; min_pf[i] || i * j &gt;= N) break;&#10;                min_pf[i * j] = j;&#10;            }&#10;        }&#10;    }&#10;&#10;    void Eratosthenes(lint N) {&#10;        for (lint i = 2; i * i &lt; N; i++) {&#10;            if (pTable[i]) {&#10;                for (int j = 0; i * (j + 2) &lt; N; j++) pTable[i * (j + 2)] = false;&#10;            }&#10;        }&#10;    }&#10;&#10;public:&#10;    vector&lt;bool&gt; pTable;&#10;&#10;    explicit Prime(int N, bool useLinear) : min_pf(N + 1) { linearSieve(N + 1); }&#10;    explicit Prime(int N = 1100000) : pTable(N + 1, true) { Eratosthenes(N + 1); }&#10;&#10;    [[nodiscard]] vector&lt;pair&lt;lint, int&gt;&gt; factorize(lint n) {&#10;        vector&lt;pair&lt;lint, int&gt;&gt; res;&#10;        for (lint i = 2; i * i &lt;= n; i++) {&#10;            int cnt = 0;&#10;            while (n % i == 0) {&#10;                cnt++;&#10;                n /= i;&#10;            }&#10;            if (cnt) res.emplace_back(i, cnt);&#10;        }&#10;        if (n != 1) res.emplace_back(n, 1);&#10;&#10;        return res;&#10;    }&#10;&#10;    // Miller-Rabin&#10;    [[nodiscard]] bool isPrime(lint n) {&#10;        if (n &lt;= 1 || n % 2 == 0) return (n == 2);&#10;        const int s = ctz(n - 1);&#10;        const lint d = (n - 1) &gt;&gt; s;&#10;        // set runtime mod&#10;        RMOD = n;&#10;        // http://miller-rabin.appspot.com/&#10;        for (const lint base : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {&#10;            rmint a = rmint(base).pow(d);&#10;            int i = s;&#10;            while (a != 1 &amp;&amp; a != -1 &amp;&amp; a != 0 &amp;&amp; i--) a *= a;&#10;            if (a != -1 &amp;&amp; i != s) return false;&#10;        }&#10;        return true;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myrandom" value="struct Random {&#10;&#10;    mt19937 mt;&#10;    Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}&#10;&#10;    lint operator()(const lint &amp;rand_min, const lint &amp;rand_max) {&#10;        uniform_int_distribution &lt;lint&gt; dist(rand_min, rand_max);&#10;        return dist(mt);&#10;    }&#10;    lint operator()(const lint &amp;rand_max) { return (*this)(0LL, rand_max); }&#10;&#10;    [[nodiscard]] vector&lt;lint&gt; uniq_vec(const int &amp;sz, const lint &amp;rand_min, lint rand_max) {&#10;&#10;        vector&lt;lint&gt; res(sz);&#10;        unordered_map &lt;lint, lint&gt; memo;&#10;        for (int i = 0; i &lt; sz; i++, rand_max--) {&#10;&#10;            lint rand_val = (*this)(rand_min, rand_max);&#10;&#10;            // If rand_max hasn't been replaced yet, fill it with rand_max&#10;            if (memo.find(rand_max) == memo.end()) memo[rand_max] = rand_max;&#10;&#10;            auto val_itr = memo.find(rand_val);&#10;            if (val_itr == memo.end()) { // replace rand_val with rand_max&#10;                memo[rand_val] = memo[rand_max];&#10;            }&#10;            else { // If rand_val has already been replaced&#10;                rand_val = val_itr-&gt;second;&#10;                val_itr-&gt;second = memo[rand_max];&#10;            }&#10;&#10;            res[i] = rand_val;&#10;        }&#10;        return res;&#10;    }&#10;    template&lt;class Ite&gt;&#10;    void shuf(Ite first, Ite last) { shuffle(first, last, mt); }&#10;&#10;    string random_string(const int &amp;max_len, const string list = &quot;abcdefghijklmnopqrstuvwxyz&quot;) {&#10;        assert(!list.empty());&#10;        int size = (int)(*this)(1, max_len);&#10;        string res(size, 0);&#10;        generate(res.begin(), res.end(), [this, &amp;list]() { return list[(*this)((int)list.size() - 1)]; });&#10;        return res;&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myrectanglesum" value="// 2d Cumulative Sum&#10;template&lt;class T&gt;&#10;class RecSum {&#10;private:&#10;    int H, W;&#10;    vector&lt;vector&lt;T&gt;&gt; data;&#10;&#10;public:&#10;    explicit RecSum(vector&lt;vector&lt;T&gt;&gt; const &amp;vec) : H(vec.size()), W(vec[0].size()), data(H + 1, vector&lt;T&gt;(W + 1, 0)) {&#10;        for (int row = 0; row &lt; H; row++) {&#10;            for (int col = 0; col &lt; W; col++) {&#10;                data[row + 1][col + 1] += data[row + 1][col] + data[row][col + 1] - data[row][col] + vec[row][col];&#10;            }&#10;        }&#10;    }&#10;&#10;    RecSum(int H, int W) : H(H), W(W), data(H + 1, vector&lt;T&gt;(W + 1, 0)) {}&#10;    void add(int x, int y, T z) { data[x + 1][y + 1] += z; }&#10;    void init() {&#10;        for (int row = 0; row &lt; H; row++) {&#10;            for (int col = 0; col &lt; W; col++) {&#10;                data[row + 1][col + 1] += data[row + 1][col] + data[row][col + 1] - data[row][col];&#10;            }&#10;        }&#10;    }&#10;&#10;    // [sx, gx) x [sy, gy)&#10;    T operator()(int sx, int sy, int gx, int gy) {&#10;        return data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy];&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myrollinghash" value="template&lt;int Modulo = MOD&gt;&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a = r.val, b = Modulo, u = 1, v = 0;&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            swap(a, b);&#10;            u -= t * v;&#10;            swap(u, v);&#10;        }&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return val ? Modulo - val : 0; }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp;&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res = 1, tmp = val;&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;using mint = Mint&lt;&gt;;&#10;&#10;//// mod, base from https://gist.github.com/privet-kitty/295ac9202b7abb3039b493f8238bf40f&#10;class RollingHash {&#10;&#10;private:&#10;    using Mod = Mint&lt;2147483647&gt;;&#10;&#10;    vector&lt;Mod&gt; hash1, pow1;&#10;    vector&lt;Mod&gt; hash2, pow2;&#10;    const int base1 = 2147483634;&#10;    const int base2 = 2147483627;&#10;    int sz;&#10;&#10;public:&#10;    explicit RollingHash(const string &amp;s) : sz(s.size()) {&#10;&#10;        hash1.assign(sz + 1, 0);&#10;        pow1.assign(sz + 1, 1);&#10;        hash2.assign(sz + 1, 0);&#10;        pow2.assign(sz + 1, 1);&#10;&#10;        for (int i = 0; i &lt; sz; i++) {&#10;            hash1[i + 1] = hash1[i] * base1 + s[i];&#10;            pow1[i + 1] = pow1[i] * base1;&#10;            hash2[i + 1] = hash2[i] * base2 + s[i];&#10;            pow2[i + 1] = pow2[i] * base2;&#10;        }&#10;    }&#10;&#10;    [[nodiscard]] pair&lt;int, int&gt; get(int l, int r) {&#10;        int res1 = (hash1[r] - hash1[l] * pow1[r - l]).val;&#10;        int res2 = (hash2[r] - hash2[l] * pow2[r - l]).val;&#10;        return {res1, res2};&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myrunlength" value="vector&lt;pair&lt;char, int&gt;&gt; runLength(string s) {&#10;    char prev = s[0];&#10;    vector&lt;pair&lt;char, int&gt;&gt; res{{prev, 0}};&#10;    for (const auto &amp;c : s) {&#10;        if (c == prev) res.back().second++;&#10;        else res.emplace_back(c, 1);&#10;        prev = c;&#10;    }&#10;    return res;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myslideminmax" value="template&lt;class T&gt;&#10;pair &lt;vector&lt;T&gt;, vector&lt;T&gt;&gt; slide_minmax(const vector&lt;T&gt; &amp;v, int k) {&#10;&#10;    deque&lt;int&gt; deq_min, deq_max;&#10;    vector&lt;T&gt; ret_min, ret_max;&#10;    for (int i = 0; i &lt; (int)v.size(); i++) {&#10;&#10;        while (!deq_min.empty() &amp;&amp; v[deq_min.back()] &gt;= v[i]) deq_min.pop_back();&#10;        while (!deq_max.empty() &amp;&amp; v[deq_max.back()] &lt;= v[i]) deq_max.pop_back();&#10;&#10;        deq_min.push_back(i);&#10;        deq_max.push_back(i);&#10;&#10;        if (i - k + 1 &gt;= 0) {&#10;            ret_min.emplace_back(v[deq_min.front()]);&#10;            ret_max.emplace_back(v[deq_max.front()]);&#10;            if (deq_min.front() == i - k + 1) deq_min.pop_front();&#10;            if (deq_max.front() == i - k + 1) deq_max.pop_front();&#10;        }&#10;&#10;    }&#10;    return {ret_min, ret_max};&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mytemplate" value="#ifdef _DEBUG&#10;#include &quot;../../../library/src/debug_template.cpp&quot;&#10;#define DMP(...) dump(#__VA_ARGS__, __VA_ARGS__)&#10;#else&#10;#define DMP(...) ((void)0)&#10;#endif&#10;&#10;#include &lt;cassert&gt;&#10;#include &lt;cstdio&gt;&#10;#include &lt;cmath&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;set&gt;&#10;#include &lt;map&gt;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;queue&gt;&#10;#include &lt;numeric&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;bitset&gt;&#10;#include &lt;functional&gt;&#10;&#10;using namespace std;&#10;using lint = long long;&#10;constexpr int MOD = 1000000007, INF = 1010101010;&#10;constexpr lint LINF = 1LL &lt;&lt; 60;&#10;&#10;struct init {&#10;    init() {&#10;        cin.tie(nullptr);&#10;        ios::sync_with_stdio(false);&#10;        cout &lt;&lt; fixed &lt;&lt; setprecision(10);&#10;    }&#10;} init_;&#10;&#10;int main() {&#10;&#10;    return 0;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mytimer" value="class Timer {&#10;public:&#10;    Timer() { reset(); }&#10;&#10;    void reset() {&#10;        start = chrono::high_resolution_clock::now();&#10;    }&#10;&#10;    [[nodiscard]] chrono::microseconds::rep elapsed() const {&#10;        auto end = chrono::high_resolution_clock::now();&#10;        return chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count();&#10;    }&#10;&#10;private:&#10;    chrono::high_resolution_clock::time_point start;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="mytopologicalsort" value="class TopologicalSort {&#10;private:&#10;    int V;&#10;    vector&lt;vector&lt;int&gt;&gt; edges;&#10;    vector&lt;int&gt; used;&#10;&#10;public:&#10;    explicit TopologicalSort(int n) : V(n), edges(n), used(n) {}&#10;    explicit TopologicalSort(vector&lt;vector&lt;int&gt;&gt; &amp;edges) : V(edges.size()), used(edges.size()) { this-&gt;edges = edges; }&#10;&#10;    void add_edge(int from, int to) { edges[from].emplace_back(to); }&#10;&#10;    vector&lt;int&gt; build() {&#10;&#10;        vector&lt;int&gt; res, in(V);&#10;        for (int i = 0; i &lt; V; i++) for (const auto &amp;e : edges[i]) in[e]++;&#10;&#10;        res.reserve(V);&#10;        queue&lt;int&gt; que;&#10;        for (int i = 0; i &lt; V; i++) {&#10;            if (in[i] == 0 &amp;&amp; !used[i]) {&#10;                used[i] = 1;&#10;                que.emplace(i);&#10;            }&#10;        }&#10;        while (!que.empty()) {&#10;            int now = que.front();&#10;            que.pop();&#10;            res.emplace_back(now);&#10;            for (const auto &amp;e : edges[now]) {&#10;                in[e]--;&#10;                if (in[e] == 0) {&#10;                    if (used[e]) return vector&lt;int&gt;(); // unable to sort&#10;                    used[e] = used[now] + 1;&#10;                    que.emplace(e);&#10;                }&#10;            }&#10;        }&#10;&#10;        return res;&#10;    }&#10;&#10;    [[nodiscard]] int longest_path() {&#10;        if (none_of(used.begin(), used.end(), [](int u) { return u &gt; 0; })) build();&#10;        return *max_element(used.begin(), used.end()) - 1;&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template><template name="myunionfind" value="class UnionFind {&#10;private:&#10;    vector&lt;int&gt; data;&#10;public:&#10;    explicit UnionFind(int size) : data(size, -1) {}&#10;    [[nodiscard]] int root(int x) { return data[x] &lt; 0 ? x : data[x] = root(data[x]); }&#10;    [[nodiscard]] bool is_same(int x, int y) { return root(x) == root(y); }&#10;    [[nodiscard]] int size(int x) { return -data[root(x)]; }&#10;&#10;    bool unify(int x, int y) {&#10;        x = root(x);&#10;        y = root(y);&#10;        if (x != y) {&#10;            if (data[y] &lt; data[x]) swap(x, y);&#10;            data[x] += data[y];&#10;            data[y] = x;&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template></templateSet>
