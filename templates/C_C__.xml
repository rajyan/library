<templateSet group="C/C++"><template name="mybellmanford" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;&#10;template&lt;class T&gt;&#10;struct Edge {&#10;    int from{}, to{};&#10;    T cost;&#10;    Edge() = default;&#10;    Edge(int to, T cost) : to(to), cost(cost) {}&#10;    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}&#10;    bool operator&gt;(const Edge &amp;r) const { return this-&gt;cost &gt; r.cost; }&#10;};&#10;&#10;template&lt;class T&gt;&#10;vector&lt;T&gt; BellmanFord(const vector&lt;Edge&lt;T&gt;&gt; &amp;edges, const int V, const int st) {&#10;&#10;    const T inf = numeric_limits&lt;T&gt;::max() / 2;&#10;    vector&lt;T&gt; cost(V, inf);&#10;    cost[st] = 0;&#10;    for (int i = 0; i &lt; V - 1; i++) {&#10;        for (const auto &amp;e : edges) {&#10;            if (cost[e.from] == inf) continue;&#10;            chmin(cost[e.to], cost[e.from] + e.cost);&#10;        }&#10;    }&#10;&#10;    for (int i = 0; i &lt; V; i++) {&#10;        for (const auto &amp;e : edges) { // finding negative loop&#10;            if (cost[e.from] == inf) continue;&#10;            if (cost[e.from] == -inf) cost[e.to] = -inf; // src is nloop -&gt; dst is nloop&#10;            else if (cost[e.to] &gt; cost[e.from] + e.cost) cost[e.to] = -inf; // chmin is possible -&gt; nloop&#10;        }&#10;    }&#10;&#10;    return cost;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mybisearch" value="template&lt;class T, class F&gt;&#10;T bisearch(T OK, T NG, F f) {&#10;    T ok = OK;&#10;    T ng = NG;&#10;&#10;    while (abs(ok - ng) &gt; 1) {&#10;        auto mid = (ok + ng) / 2;&#10;&#10;        if (f(mid)) ok = mid;&#10;        else ng = mid;&#10;    }&#10;&#10;    return ok;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mychmax" value="template&lt;class T&gt;&#10;inline bool chmax(T &amp;a, const T b) { return a &lt; b &amp;&amp; (a = b, true); }&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mychmin" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myclz" value="inline int clz(lint x) {&#10;    union {&#10;        unsigned long long as_uint64;&#10;        double as_double;&#10;    } data{};&#10;    data.as_double = (double)x + 0.5;&#10;    int n = 1054 - (int)(data.as_uint64 &gt;&gt; 52);&#10;    return 32 + n;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mycombination" value="template&lt;const int &amp;Modulo&gt;&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a{r.val}, b{Modulo}, u{1}, v{0};&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            a ^= b, b ^= a, a ^= b;&#10;            u -= t * v;&#10;            u ^= v, v ^= u, u ^= v;&#10;        }&#10;        assert(a == 1);&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return Mint(-val); }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    constexpr friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    constexpr friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp{};&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res{1}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;constexpr int MOD = 1000000007;&#10;using mint = Mint&lt;MOD&gt;;&#10;&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;&#10;template&lt;class T = mint&gt;&#10;class Combination {&#10;public:&#10;    explicit Combination(int N = 110000) : fac(N + 1), inv(N + 1), finv(N + 1) { build(N + 1); }&#10;&#10;    T operator()(int n, int k) {&#10;        if (n &lt; k || k &lt; 0) return 0LL;&#10;        return fac[n] * (finv[k] * finv[n - k]);&#10;    }&#10;&#10;private:&#10;    void build(int N) {&#10;        fac[0] = fac[1] = 1;&#10;        inv[1] = 1;&#10;        finv[0] = finv[1] = 1;&#10;&#10;        for (int i = 2; i &lt; N; i++) {&#10;            fac[i] = fac[i - 1] * i;&#10;            inv[i] = -inv[MOD % i] * (MOD / i);&#10;            finv[i] = finv[i - 1] * inv[i];&#10;        }&#10;    }&#10;&#10;    vector&lt;T&gt; fac, inv, finv;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mycompress" value="template&lt;class T&gt;&#10;class Compress {&#10;public:&#10;    Compress() = default;&#10;    explicit Compress(const vector&lt;T&gt; &amp;vec) : comp(vec) { build(); }&#10;&#10;    void add(const T &amp;x) { comp.emplace_back(x); }&#10;&#10;    void build() {&#10;        sort(comp.begin(), comp.end());&#10;        comp.erase(unique(comp.begin(), comp.end(), comp.end()));&#10;    }&#10;&#10;    [[nodiscard]] vector&lt;int&gt; get(const vector&lt;T&gt; &amp;vec) const {&#10;        vector&lt;int&gt; ret(vec.size());&#10;        transform(vec.begin(), vec.end(), ret.begin(), [&amp;](const T &amp;x) { return get(x); });&#10;        return ret;&#10;    }&#10;    [[nodiscard]] int get(const T &amp;x) const { return lower_bound(comp.begin(), comp.end(), x) - begin(comp); }&#10;&#10;    const T &amp;operator[](const int k) const { return comp[k]; }&#10;&#10;private:&#10;    vector&lt;T&gt; comp{};&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myctz" value="inline int popcount(lint n) {&#10;    n = (n &amp; 0x5555555555555555) + (n &gt;&gt; 1 &amp; 0x5555555555555555);&#10;    n = (n &amp; 0x3333333333333333) + (n &gt;&gt; 2 &amp; 0x3333333333333333);&#10;    n = (n &amp; 0x0f0f0f0f0f0f0f0f) + (n &gt;&gt; 4 &amp; 0x0f0f0f0f0f0f0f0f);&#10;    n = (n &amp; 0x00ff00ff00ff00ff) + (n &gt;&gt; 8 &amp; 0x00ff00ff00ff00ff);&#10;    n = (n &amp; 0x0000ffff0000ffff) + (n &gt;&gt; 16 &amp; 0x0000ffff0000ffff);&#10;    n = (n &amp; 0x00000000ffffffff) + (n &gt;&gt; 32 &amp; 0x00000000ffffffff);&#10;    return n;&#10;}#pragma once&#10;&#10;inline int ctz(lint n) {&#10;    return popcount(~n &amp; (n - 1));&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mycumulativesum" value="template&lt;class T&gt;&#10;class CuSum {&#10;public:&#10;    explicit CuSum(vector&lt;T&gt; const &amp;vec) : cusum(vec.size() + 1) {&#10;        for (int i = 0; i &lt; (int)vec.size(); i++) cusum[i + 1] = cusum[i] + vec[i];&#10;    }&#10;&#10;    // partial sum of 0-indexed [0, k)&#10;    [[nodiscard]] T sum(int k) {&#10;        assert(0 &lt;= k &amp;&amp; k &lt; cusum.size());&#10;        return cusum[k];&#10;    }&#10;    // partial sum of 0-indexed [l, r)&#10;    [[nodiscard]] T sum(int l, int r) {&#10;        assert(l &lt;= r);&#10;        return sum(r) - sum(l);&#10;    }&#10;&#10;private:&#10;    vector&lt;T&gt; cusum;&#10;};&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mydebugtemplate" value="#define _CRT_SECURE_NO_WARNINGS&#10;&#10;#include &lt;iostream&gt;&#10;&#10;#include &quot;print.hpp&quot;&#10;&#10;using namespace std;&#10;&#10;template&lt;class T&gt;&#10;void dump(const char *name, T &amp;&amp;h) { cerr &lt;&lt; name &lt;&lt; &quot; = &quot; &lt;&lt; str(h) &lt;&lt; &quot;\n&quot;; };&#10;template&lt;class Head, class... Tail&gt;&#10;void dump(const char *names, Head &amp;&amp;h, Tail &amp;&amp;... t) {&#10;    while (*names != ',') cerr &lt;&lt; *names++;&#10;    cerr &lt;&lt; &quot; = &quot; &lt;&lt; str(h) &lt;&lt; &quot;\n&quot;;&#10;    dump(names + (*(names + 1) == ' ' ? 2 : 1), t...);&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mydijkstra" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;&#10;template&lt;class T&gt;&#10;struct Edge {&#10;    int from{}, to{};&#10;    T cost;&#10;    Edge() = default;&#10;    Edge(int to, T cost) : to(to), cost(cost) {}&#10;    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}&#10;    bool operator&gt;(const Edge &amp;r) const { return this-&gt;cost &gt; r.cost; }&#10;};&#10;&#10;template&lt;class T&gt;&#10;vector&lt;T&gt; Dijkstra(const vector&lt;vector&lt;Edge&lt;T&gt;&gt;&gt; &amp;edges, const int st) {&#10;&#10;    const int V = (int)edges.size();&#10;    const T inf = numeric_limits&lt;T&gt;::max() / 2;&#10;    vector&lt;T&gt; cost(V, inf);&#10;    cost[st] = 0;&#10;&#10;    priority_queue &lt;Edge&lt;T&gt;, vector&lt;Edge&lt;T&gt;&gt;, greater&lt;&gt;&gt; pq;&#10;    pq.emplace(st, cost[st]);&#10;&#10;    while (!pq.empty()) {&#10;&#10;        Edge&lt;T&gt; now(pq.top().to, pq.top().cost);&#10;        pq.pop();&#10;&#10;        if (cost[now.to] &lt; now.cost) continue;&#10;        for (const Edge&lt;T&gt; &amp;e : edges[now.to]) {&#10;            T tmp_cost = now.cost + e.cost;&#10;            if (chmin(cost[e.to], tmp_cost)) {&#10;                pq.emplace(e.to, cost[e.to]);&#10;            }&#10;        }&#10;    }&#10;&#10;    return cost; // min cost to vertex idx from st&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mydivisor" value="template&lt;class T&gt;&#10;vector&lt;T&gt; divisor(const T n) {&#10;    vector&lt;T&gt; res;&#10;    for (T i = 1; i * i &lt;= n; i++) {&#10;        if (n % i == 0) {&#10;            res.emplace_back(i);&#10;            if (i * i != n) res.emplace_back(n / i);&#10;        }&#10;    }&#10;    sort(res.begin(), res.end());&#10;    return res;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myedge" value="template&lt;class T&gt;&#10;struct Edge {&#10;    int from{}, to{};&#10;    T cost;&#10;    Edge() = default;&#10;    Edge(int to, T cost) : to(to), cost(cost) {}&#10;    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}&#10;    bool operator&gt;(const Edge &amp;r) const { return this-&gt;cost &gt; r.cost; }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myfactorial" value="template&lt;const int &amp;Modulo&gt;&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a{r.val}, b{Modulo}, u{1}, v{0};&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            a ^= b, b ^= a, a ^= b;&#10;            u -= t * v;&#10;            u ^= v, v ^= u, u ^= v;&#10;        }&#10;        assert(a == 1);&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return Mint(-val); }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    constexpr friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    constexpr friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp{};&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res{1}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;constexpr int MOD = 1000000007;&#10;using mint = Mint&lt;MOD&gt;;&#10;&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;&#10;class Factorial {&#10;public:&#10;    explicit Factorial(int N = 110000) : fac(N + 1), inv(N + 1), finv(N + 1) { build(N + 1); }&#10;&#10;    [[nodiscard]] mint Cmod(int n, int k) {&#10;        if (n &lt; k || k &lt; 0) return 0LL;&#10;        return fac[n] * (finv[k] * finv[n - k]);&#10;    }&#10;&#10;    [[nodiscard]] mint Pmod(int n, int k) {&#10;        if (n &lt; k || k &lt; 0) return 0LL;&#10;        return fac[n] * finv[n - k];&#10;    }&#10;&#10;    [[nodiscard]] mint Hmod(int n, int k) {&#10;        if (n &lt; 0 || k &lt; 0) return 0LL;&#10;        return k == 0 ? 1 : Cmod(n + k - 1, k);&#10;    }&#10;&#10;private:&#10;    void build(int N) {&#10;        fac[0] = fac[1] = 1;&#10;        inv[1] = 1;&#10;        finv[0] = finv[1] = 1;&#10;&#10;        for (int i = 2; i &lt; N; i++) {&#10;            fac[i] = fac[i - 1] * i;&#10;            inv[i] = -inv[MOD % i] * (MOD / i);&#10;            finv[i] = finv[i - 1] * inv[i];&#10;        }&#10;    }&#10;&#10;    vector&lt;mint&gt; fac, inv, finv;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myfenwicktree" value="template&lt;class T&gt;&#10;class FenwickTree {&#10;public:&#10;    explicit FenwickTree(int sz, T &amp;&amp;x = T{}) : n(sz), bit(n + 1) {&#10;        for (int i = 0; i &lt; n; i++) add(i, x);&#10;    }&#10;&#10;    void add(int k, const T &amp;x) { for (; k &lt; n; k |= k + 1) bit[k] += x; }&#10;    void set(int k, const T &amp;x) { add(k, x - sum(k, k + 1)); }&#10;&#10;    [[nodiscard]] T sum(int k) const {&#10;        T res = 0;&#10;        for (k--; k &gt;= 0; k = (k &amp; (k + 1)) - 1) res += bit[k];&#10;        return res;&#10;    }&#10;    [[nodiscard]] T sum(int l, int r) const { return sum(r) - sum(l); }&#10;&#10;private:&#10;    int n;&#10;    vector&lt;T&gt; bit;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myfloydwarshall" value="template&lt;class T&gt;&#10;inline bool chmin(T &amp;a, const T b) { return a &gt; b &amp;&amp; (a = b, true); }&#10;&#10;template&lt;class T&gt;&#10;vector&lt;vector&lt;T&gt;&gt; FloydWarshall(const vector&lt;vector&lt;T&gt;&gt; &amp;in, const T diag = T{}) {&#10;&#10;    const int N = in.size();&#10;    assert(N == (int)in[0].size());&#10;    const T inf = in[0][0];&#10;&#10;    auto d = in;&#10;    for (int i = 0; i &lt; N; i++) d[i][i] = diag;&#10;    for (int k = 0; k &lt; N; k++) {&#10;        for (int i = 0; i &lt; N; i++) {&#10;            for (int j = 0; j &lt; N; j++) {&#10;                if (d[i][k] &lt; inf &amp;&amp; d[k][j] &lt; inf) chmin(d[i][j], d[i][k] + d[k][j]);&#10;            }&#10;        }&#10;    }&#10;    return d;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myfnv1a" value="inline uint64_t fnv1a_64(const string&amp; data) {&#10;&#10;    uint64_t hash = 0xcbf29ce484222325;&#10;    constexpr uint64_t prime = 0x100000001b3;&#10;&#10;    for (char i : data) {&#10;        hash = hash ^ i;&#10;        hash *= prime;&#10;    }&#10;&#10;    return hash;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mylowestcommonancestor" value="inline int clz(lint x) {&#10;    union {&#10;        unsigned long long as_uint64;&#10;        double as_double;&#10;    } data{};&#10;    data.as_double = (double)x + 0.5;&#10;    int n = 1054 - (int)(data.as_uint64 &gt;&gt; 52);&#10;    return 32 + n;&#10;}&#10;&#10;class LCA {&#10;public:&#10;    explicit LCA(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, int root = 0) : N(tree.size()), lg_N(64 - clz(N)), depth(N),&#10;                                                                  par(lg_N + 1, vector&lt;int&gt;(N, -1)) { build(tree, root); }&#10;&#10;    int get_lca(int u, int v) {&#10;&#10;        if (depth[u] &lt; depth[v]) swap(u, v);&#10;        u = ancestor(u, depth[u] - depth[v]);&#10;        if (u == v) return u;&#10;&#10;        for (int i = 64 - clz(depth[u]); i &gt;= 0; i--) {&#10;            if (par[i][u] != par[i][v]) {&#10;                u = par[i][u];&#10;                v = par[i][v];&#10;            }&#10;        }&#10;        return par[0][u];&#10;    }&#10;&#10;    int dist(int u, int v) {&#10;        return depth[u] + depth[v] - 2 * depth[get_lca(u, v)];&#10;    }&#10;&#10;private:&#10;    void build(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, int root) {&#10;&#10;        auto dfs = [&amp;](auto &amp;&amp;f, int now) -&gt; void {&#10;            for (const auto &amp;next : tree[now]) {&#10;                if (par[0][next] == -1) {&#10;                    par[0][next] = now;&#10;                    depth[next] = depth[now] + 1;&#10;                    f(f, next);&#10;                }&#10;            }&#10;        };&#10;&#10;        par[0][root] = root;&#10;        dfs(dfs, root);&#10;&#10;        for (int bit = 0; bit &lt; lg_N; bit++) {&#10;            for (int i = 0; i &lt; N; i++) {&#10;                par[bit + 1][i] = par[bit][par[bit][i]];&#10;            }&#10;        }&#10;    }&#10;&#10;    [[nodiscard]] int ancestor(int now, int n) {&#10;        if (n &lt;= 0) return now;&#10;        for (int i = 0, lg_n = 64 - clz(n); i &lt; lg_n; i++) {&#10;            if (n &amp; (1LL &lt;&lt; i)) now = par[i][now];&#10;        }&#10;        return now;&#10;    }&#10;&#10;    int N, lg_N;&#10;    vector&lt;int&gt; depth;&#10;    vector&lt;vector&lt;int&gt;&gt; par;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mymakevec" value="template&lt;class T&gt;&#10;vector&lt;T&gt; make_vec(size_t s, T val) { return vector&lt;T&gt;(s, val); }&#10;template&lt;class... Size&gt;&#10;auto make_vec(size_t s, Size... tail) {&#10;    return vector&lt;decltype(make_vec(tail...))&gt;(s, make_vec(tail...));&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mymatrix2d" value="template&lt;class T&gt;&#10;struct Point2D {&#10;    T x{}, y{};&#10;&#10;    constexpr Point2D() = default;&#10;    constexpr Point2D(const T &amp;x, const T &amp;y) noexcept: x(x), y(y) {};&#10;    constexpr explicit Point2D(const pair&lt;T, T&gt; &amp;p) noexcept: x(p.first), y(p.second) {};&#10;&#10;    constexpr bool operator==(const Point2D &amp;rhs) const noexcept { return x == rhs.x &amp;&amp; y == rhs.y; }&#10;    constexpr bool operator!=(const Point2D &amp;rhs) const noexcept { return !(*this == rhs); }&#10;    constexpr bool operator&lt;(const Point2D &amp;rhs) const noexcept { return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); }&#10;    constexpr bool operator&gt;(const Point2D &amp;rhs) const noexcept { return rhs &lt; *this; }&#10;    constexpr bool operator&lt;=(const Point2D &amp;rhs) const noexcept { return !(*this &gt; rhs); }&#10;    constexpr bool operator&gt;=(const Point2D &amp;rhs) const noexcept { return !(*this &lt; rhs); }&#10;&#10;    constexpr Point2D operator+(const Point2D &amp;rhs) const noexcept { return {x + rhs.x, y + rhs.y}; }&#10;    constexpr Point2D operator-(const Point2D &amp;rhs) const noexcept { return {x - rhs.x, y - rhs.y}; }&#10;    constexpr Point2D operator*(const T &amp;k) const noexcept { return {k * x, k * y}; }&#10;    constexpr Point2D operator/(const T &amp;k) const noexcept { return {x / k, y / k}; }&#10;    constexpr Point2D &amp;operator+=(const Point2D &amp;rhs) noexcept { return *this = *this + rhs; }&#10;    constexpr Point2D &amp;operator-=(const Point2D &amp;rhs) noexcept { return *this = *this - rhs; }&#10;    constexpr Point2D &amp;operator*=(const T &amp;k) noexcept { return *this = *this * k; }&#10;    constexpr Point2D &amp;operator/=(const T &amp;k) noexcept { return *this = *this / k; }&#10;    constexpr Point2D &amp;operator--() noexcept { return *this -= Point2D(1, 1); };&#10;    constexpr Point2D &amp;operator++() noexcept { return *this += Point2D(1, 1); };&#10;    constexpr Point2D operator--(int) noexcept { Point2D res = *this; --*this; return res; };&#10;    constexpr Point2D operator++(int) noexcept { Point2D res = *this; ++*this; return res; };&#10;    constexpr Point2D operator-() const noexcept { return {-x, -y}; }&#10;&#10;    constexpr T operator*(const Point2D &amp;rhs) const noexcept { return x * rhs.x + y * rhs.y; }&#10;&#10;    [[nodiscard]] constexpr Point2D nor() const noexcept { return {y, -x}; }&#10;    [[nodiscard]] constexpr long double hypot() const noexcept { return ::hypotl(x, y); }&#10;    [[nodiscard]] constexpr bool inGrid(const T &amp;H, const T &amp;W) const noexcept { return 0 &lt;= x &amp;&amp; x &lt; H &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; W; }&#10;    template&lt;class U&gt;&#10;    [[nodiscard]] constexpr U &amp;operator[](vector&lt;vector&lt;U&gt;&gt; &amp;v) const noexcept { return v[x][y]; }&#10;&#10;    constexpr friend istream &amp;operator&gt;&gt;(istream &amp;is, Point2D &amp;p) { return is &gt;&gt; p.x &gt;&gt; p.y; }&#10;    constexpr friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point2D &amp;p) { return os &lt;&lt; p.x &lt;&lt; ' ' &lt;&lt; p.y; }&#10;};&#10;&#10;using pnt = Point2D&lt;lint&gt;;&#10;&#10;template&lt;class T&gt;&#10;struct Matrix2D {&#10;    Point2D&lt;T&gt; r0{}, r1{};&#10;&#10;    constexpr Matrix2D() = default;&#10;    constexpr Matrix2D(const Point2D&lt;T&gt; &amp;r0_, const Point2D&lt;T&gt; &amp;r1_) noexcept: r0(r0_), r1(r1_) {};&#10;    constexpr explicit Matrix2D(const T &amp;diag) noexcept: r0{diag, 0}, r1{0, diag} {}&#10;&#10;    constexpr bool operator==(const Matrix2D &amp;rhs) const noexcept { return r0 == rhs.r0 &amp;&amp; r1 == rhs.r1; }&#10;    constexpr bool operator!=(const Matrix2D &amp;rhs) const noexcept { return !(*this == rhs); }&#10;&#10;    constexpr Matrix2D operator+(const Matrix2D &amp;rhs) const noexcept { return {r0 + rhs.r0, r1 + rhs.r1}; }&#10;    constexpr Matrix2D operator-(const Matrix2D &amp;rhs) const noexcept { return {r0 - rhs.r0, r1 - rhs.r1}; }&#10;    constexpr Matrix2D operator*(const Matrix2D &amp;rhs) const noexcept {&#10;        const Matrix2D rhs_T = rhs.trans();&#10;        return {{r0 * rhs_T.r0, r0 * rhs_T.r1},&#10;                {r1 * rhs_T.r0, r1 * rhs_T.r1}};&#10;    }&#10;    constexpr Matrix2D &amp;operator+=(const Matrix2D &amp;rhs) noexcept { return *this = *this + rhs; }&#10;    constexpr Matrix2D &amp;operator-=(const Matrix2D &amp;rhs) noexcept { return *this = *this - rhs; }&#10;    constexpr Matrix2D &amp;operator*=(const Matrix2D &amp;rhs) noexcept { return *this = *this * rhs; }&#10;    constexpr Matrix2D operator-() const noexcept { return {-r0, -r1}; }&#10;&#10;    constexpr Point2D&lt;T&gt; operator*(const Point2D&lt;T&gt; &amp;b_T) const noexcept { return {r0 * b_T, r1 * b_T}; }&#10;&#10;    [[nodiscard]] constexpr Matrix2D trans() const noexcept {&#10;        return {{r0.x, r1.x},&#10;                {r0.y, r1.y}};&#10;    }&#10;    [[nodiscard]] constexpr Matrix2D identity() const noexcept { return Matrix2D{T{1}}; }&#10;    [[nodiscard]] constexpr Matrix2D pow(lint n) const noexcept {&#10;        Matrix2D res{Matrix2D{}.identity()}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;    [[nodiscard]] constexpr T det() const noexcept { return r0 * r1.nor(); }&#10;};&#10;&#10;using mat = Matrix2D&lt;lint&gt;;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mymodint" value="template&lt;const int &amp;Modulo&gt;&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a{r.val}, b{Modulo}, u{1}, v{0};&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            a ^= b, b ^= a, a ^= b;&#10;            u -= t * v;&#10;            u ^= v, v ^= u, u ^= v;&#10;        }&#10;        assert(a == 1);&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return Mint(-val); }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    constexpr friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    constexpr friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp{};&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res{1}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;constexpr int MOD = 1000000007;&#10;using mint = Mint&lt;MOD&gt;;&#10;&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mymodpow" value="lint modpow(lint a, lint n, lint mod = 1000000007) {&#10;    lint res = 1;&#10;    while (n &gt; 0) {&#10;        if (n &amp; 1) res = res * a % mod;&#10;        a = a * a % mod;&#10;        n &gt;&gt;= 1;&#10;    }&#10;    return res;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mymonoid" value="template&lt;class T, T (*base_op)(T, T), const T(*e) = nullptr&gt;&#10;class Monoid {&#10;    class Identity {};&#10;    constexpr static bool has_identity = (e != nullptr);&#10;public:&#10;    using type = T;&#10;    using vt = conditional_t&lt;has_identity, T, variant&lt;Identity, T&gt;&gt;;&#10;&#10;    [[nodiscard]] constexpr vt op(const vt &amp;a, const vt &amp;b) const {&#10;        if constexpr (has_identity) return base_op(a, b);&#10;        else if (a.index() == 1 &amp;&amp; b.index() == 1) return base_op(get&lt;T&gt;(a), get&lt;T&gt;(b));&#10;        else if (a.index() == 0) return b;&#10;        else return a;&#10;    };&#10;    [[nodiscard]] constexpr vt identity() const {&#10;        if constexpr (has_identity) return *e;&#10;        else return Identity{};&#10;    }&#10;};&#10;&#10;namespace monoid {&#10;    constexpr auto op_add = [](auto l, auto r) { return l + r; };&#10;    constexpr auto op_mul = [](auto l, auto r) { return l * r; };&#10;    constexpr auto op_max = [](auto l, auto r) { return max(l, r); };&#10;    constexpr auto op_min = [](auto l, auto r) { return min(l, r); };&#10;    template&lt;class T&gt; T e_add = T{};&#10;    template&lt;class T&gt; T e_mul = T{1};&#10;    template&lt;class T&gt; T e_max = numeric_limits&lt;T&gt;::max();&#10;    template&lt;class T&gt; T e_min = numeric_limits&lt;T&gt;::min();&#10;    template&lt;class T&gt; using add = Monoid&lt;T, monoid::op_add, &amp;monoid::e_add&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using mul = Monoid&lt;T, monoid::op_mul, &amp;monoid::e_mul&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using max = Monoid&lt;T, monoid::op_max, &amp;monoid::e_max&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using min = Monoid&lt;T, monoid::op_min, &amp;monoid::e_min&lt;T&gt;&gt;;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mypoint2d" value="template&lt;class T&gt;&#10;struct Point2D {&#10;    T x{}, y{};&#10;&#10;    constexpr Point2D() = default;&#10;    constexpr Point2D(const T &amp;x, const T &amp;y) noexcept: x(x), y(y) {};&#10;    constexpr explicit Point2D(const pair&lt;T, T&gt; &amp;p) noexcept: x(p.first), y(p.second) {};&#10;&#10;    constexpr bool operator==(const Point2D &amp;rhs) const noexcept { return x == rhs.x &amp;&amp; y == rhs.y; }&#10;    constexpr bool operator!=(const Point2D &amp;rhs) const noexcept { return !(*this == rhs); }&#10;    constexpr bool operator&lt;(const Point2D &amp;rhs) const noexcept { return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); }&#10;    constexpr bool operator&gt;(const Point2D &amp;rhs) const noexcept { return rhs &lt; *this; }&#10;    constexpr bool operator&lt;=(const Point2D &amp;rhs) const noexcept { return !(*this &gt; rhs); }&#10;    constexpr bool operator&gt;=(const Point2D &amp;rhs) const noexcept { return !(*this &lt; rhs); }&#10;&#10;    constexpr Point2D operator+(const Point2D &amp;rhs) const noexcept { return {x + rhs.x, y + rhs.y}; }&#10;    constexpr Point2D operator-(const Point2D &amp;rhs) const noexcept { return {x - rhs.x, y - rhs.y}; }&#10;    constexpr Point2D operator*(const T &amp;k) const noexcept { return {k * x, k * y}; }&#10;    constexpr Point2D operator/(const T &amp;k) const noexcept { return {x / k, y / k}; }&#10;    constexpr Point2D &amp;operator+=(const Point2D &amp;rhs) noexcept { return *this = *this + rhs; }&#10;    constexpr Point2D &amp;operator-=(const Point2D &amp;rhs) noexcept { return *this = *this - rhs; }&#10;    constexpr Point2D &amp;operator*=(const T &amp;k) noexcept { return *this = *this * k; }&#10;    constexpr Point2D &amp;operator/=(const T &amp;k) noexcept { return *this = *this / k; }&#10;    constexpr Point2D &amp;operator--() noexcept { return *this -= Point2D(1, 1); };&#10;    constexpr Point2D &amp;operator++() noexcept { return *this += Point2D(1, 1); };&#10;    constexpr Point2D operator--(int) noexcept { Point2D res = *this; --*this; return res; };&#10;    constexpr Point2D operator++(int) noexcept { Point2D res = *this; ++*this; return res; };&#10;    constexpr Point2D operator-() const noexcept { return {-x, -y}; }&#10;&#10;    constexpr T operator*(const Point2D &amp;rhs) const noexcept { return x * rhs.x + y * rhs.y; }&#10;&#10;    [[nodiscard]] constexpr Point2D nor() const noexcept { return {y, -x}; }&#10;    [[nodiscard]] constexpr long double hypot() const noexcept { return ::hypotl(x, y); }&#10;    [[nodiscard]] constexpr bool inGrid(const T &amp;H, const T &amp;W) const noexcept { return 0 &lt;= x &amp;&amp; x &lt; H &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; W; }&#10;    template&lt;class U&gt;&#10;    [[nodiscard]] constexpr U &amp;operator[](vector&lt;vector&lt;U&gt;&gt; &amp;v) const noexcept { return v[x][y]; }&#10;&#10;    constexpr friend istream &amp;operator&gt;&gt;(istream &amp;is, Point2D &amp;p) { return is &gt;&gt; p.x &gt;&gt; p.y; }&#10;    constexpr friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point2D &amp;p) { return os &lt;&lt; p.x &lt;&lt; ' ' &lt;&lt; p.y; }&#10;};&#10;&#10;using pnt = Point2D&lt;lint&gt;;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mypopcount" value="inline int popcount(lint n) {&#10;    n = (n &amp; 0x5555555555555555) + (n &gt;&gt; 1 &amp; 0x5555555555555555);&#10;    n = (n &amp; 0x3333333333333333) + (n &gt;&gt; 2 &amp; 0x3333333333333333);&#10;    n = (n &amp; 0x0f0f0f0f0f0f0f0f) + (n &gt;&gt; 4 &amp; 0x0f0f0f0f0f0f0f0f);&#10;    n = (n &amp; 0x00ff00ff00ff00ff) + (n &gt;&gt; 8 &amp; 0x00ff00ff00ff00ff);&#10;    n = (n &amp; 0x0000ffff0000ffff) + (n &gt;&gt; 16 &amp; 0x0000ffff0000ffff);&#10;    n = (n &amp; 0x00000000ffffffff) + (n &gt;&gt; 32 &amp; 0x00000000ffffffff);&#10;    return n;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myprime" value="template&lt;const int &amp;Modulo&gt;&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a{r.val}, b{Modulo}, u{1}, v{0};&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            a ^= b, b ^= a, a ^= b;&#10;            u -= t * v;&#10;            u ^= v, v ^= u, u ^= v;&#10;        }&#10;        assert(a == 1);&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return Mint(-val); }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    constexpr friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    constexpr friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp{};&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res{1}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;constexpr int MOD = 1000000007;&#10;using mint = Mint&lt;MOD&gt;;&#10;&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;&#10;inline int ctz(lint n) {&#10;    return popcount(~n &amp; (n - 1));&#10;}#pragma once&#10;&#10;class Prime {&#10;public:&#10;    explicit Prime(int N = 1100000) : pTable(N + 1, true) { Eratosthenes(N + 1); }&#10;&#10;    [[nodiscard]] vector&lt;pair&lt;lint, int&gt;&gt; factorize(lint n) {&#10;        vector&lt;pair&lt;lint, int&gt;&gt; res;&#10;        for (lint i = 2; i * i &lt;= n; i++) {&#10;            int cnt = 0;&#10;            while (n % i == 0) {&#10;                cnt++;&#10;                n /= i;&#10;            }&#10;            if (cnt) res.emplace_back(i, cnt);&#10;        }&#10;        if (n != 1) res.emplace_back(n, 1);&#10;&#10;        return res;&#10;    }&#10;&#10;    // Miller-Rabin&#10;    [[nodiscard]] bool isPrime(lint n) {&#10;        if (n &lt;= 1 || n % 2 == 0) return (n == 2);&#10;        if (n &lt; (int)pTable.size()) return pTable[n];&#10;        const int s = ctz(n - 1);&#10;        const lint d = (n - 1) &gt;&gt; s;&#10;        // set runtime mod&#10;        RMOD = n;&#10;        // http://miller-rabin.appspot.com/&#10;        for (const lint base : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {&#10;            rmint a = rmint(base).pow(d);&#10;            int i = s;&#10;            while (a != 1 &amp;&amp; a != -1 &amp;&amp; a != 0 &amp;&amp; i--) a *= a;&#10;            if (a != -1 &amp;&amp; i != s) return false;&#10;        }&#10;        return true;&#10;    }&#10;private:&#10;    void Eratosthenes(lint N) {&#10;        for (lint i = 2; i * i &lt; N; i++) {&#10;            if (pTable[i]) {&#10;                for (int j = 0; i * (j + 2) &lt; N; j++) pTable[i * (j + 2)] = false;&#10;            }&#10;        }&#10;    }&#10;&#10;    vector&lt;bool&gt; pTable;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myprint" value="struct params { string d, l, r, lp, rp; };&#10;#ifdef _DEBUG&#10;params p_{&quot;,&quot;, &quot;[&quot;, &quot;]&quot;, &quot;(&quot;, &quot;)&quot;};&#10;#else&#10;params p_{&quot; &quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;};&#10;#endif&#10;&#10;template&lt;typename T, typename = void_t&lt;&gt;&gt;&#10;struct iterable: false_type {};&#10;template&lt;typename T&gt;&#10;struct iterable&lt;T, void_t&lt;decltype(declval&lt;T&gt;().begin(), declval&lt;T&gt;().end())&gt;&gt;: negation&lt;is_same&lt;T, string&gt;&gt; {};&#10;&#10;template&lt;class T&gt;&#10;enable_if_t&lt;!iterable&lt;T&gt;::value, string&gt; str(const T &amp;v) {&#10;    stringstream ss;&#10;    ss &lt;&lt; v;&#10;    return ss.str();&#10;}&#10;template&lt;class ...T&gt;&#10;string str(const pair&lt;T...&gt; &amp;t) {&#10;    return p_.lp + str(t.first) + p_.d + str(t.second) + p_.rp;&#10;}&#10;template&lt;class T&gt;&#10;enable_if_t&lt;iterable&lt;T&gt;::value, string&gt; str(const T &amp;r) {&#10;    string res(p_.l);&#10;    for (const auto &amp;e : r) res += str(e) + (&amp;e != &amp;*prev(r.end()) ? p_.d : &quot;&quot;);&#10;    return res + p_.r;&#10;}&#10;&#10;template&lt;class T&gt;&#10;void print(T &amp;&amp;o) {&#10;    cout &lt;&lt; str(o) &lt;&lt; '\n';&#10;    exit(0);&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myrandom" value="struct Random {&#10;    unsigned int seed;&#10;    mt19937 mt;&#10;    explicit Random(unsigned int s = chrono::steady_clock::now().time_since_epoch().count()) : seed(s), mt(seed) {}&#10;&#10;    lint operator()(const lint &amp;rand_min, const lint &amp;rand_max) {&#10;        uniform_int_distribution &lt;lint&gt; dist(rand_min, rand_max);&#10;        return dist(mt);&#10;    }&#10;    lint operator()(const lint &amp;rand_max) { return (*this)(0LL, rand_max); }&#10;&#10;    [[nodiscard]] vector&lt;lint&gt; uniq_vec(const int &amp;sz, const lint &amp;rand_min, lint rand_max) {&#10;&#10;        vector&lt;lint&gt; res(sz);&#10;        unordered_map &lt;lint, lint&gt; memo;&#10;        for (int i = 0; i &lt; sz; i++, rand_max--) {&#10;&#10;            lint rand_val = (*this)(rand_min, rand_max);&#10;&#10;            // If rand_max hasn't been replaced yet, fill it with rand_max&#10;            if (memo.find(rand_max) == memo.end()) memo[rand_max] = rand_max;&#10;&#10;            auto val_itr = memo.find(rand_val);&#10;            if (val_itr == memo.end()) { // replace rand_val with rand_max&#10;                memo[rand_val] = memo[rand_max];&#10;            }&#10;            else { // If rand_val has already been replaced&#10;                rand_val = val_itr-&gt;second;&#10;                val_itr-&gt;second = memo[rand_max];&#10;            }&#10;&#10;            res[i] = rand_val;&#10;        }&#10;        return res;&#10;    }&#10;    template&lt;class Ite&gt;&#10;    void shuf(Ite first, Ite last) { shuffle(first, last, mt); }&#10;&#10;    string random_string(const int &amp;max_len, const string list = &quot;abcdefghijklmnopqrstuvwxyz&quot;) {&#10;        assert(!list.empty());&#10;        int size = (int)(*this)(1, max_len);&#10;        string res(size, 0);&#10;        generate(res.begin(), res.end(), [this, &amp;list]() { return list[(*this)((int)list.size() - 1)]; });&#10;        return res;&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myrollinghash" value="template&lt;const int &amp;Modulo&gt;&#10;struct Mint {&#10;&#10;    lint val;&#10;    constexpr Mint(lint v = 0) noexcept: val(v % Modulo) { if (val &lt; 0) val += Modulo; }&#10;&#10;    constexpr Mint &amp;operator+=(const Mint &amp;r) noexcept {&#10;        val += r.val;&#10;        if (val &gt;= Modulo) val -= Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator-=(const Mint &amp;r) noexcept {&#10;        val -= r.val;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator*=(const Mint &amp;r) noexcept {&#10;        val = val * r.val % Modulo;&#10;        return *this;&#10;    }&#10;    constexpr Mint &amp;operator/=(const Mint &amp;r) noexcept {&#10;        lint a{r.val}, b{Modulo}, u{1}, v{0};&#10;        while (b) {&#10;            lint t = a / b;&#10;            a -= t * b;&#10;            a ^= b, b ^= a, a ^= b;&#10;            u -= t * v;&#10;            u ^= v, v ^= u, u ^= v;&#10;        }&#10;        assert(a == 1);&#10;        val = val * u % Modulo;&#10;        if (val &lt; 0) val += Modulo;&#10;        return *this;&#10;    }&#10;&#10;    constexpr Mint operator+(const Mint &amp;r) const noexcept { return Mint(*this) += r; }&#10;    constexpr Mint operator-(const Mint &amp;r) const noexcept { return Mint(*this) -= r; }&#10;    constexpr Mint operator*(const Mint &amp;r) const noexcept { return Mint(*this) *= r; }&#10;    constexpr Mint operator/(const Mint &amp;r) const noexcept { return Mint(*this) /= r; }&#10;&#10;    constexpr Mint operator-() const noexcept { return Mint(-val); }&#10;&#10;    constexpr bool operator==(const Mint &amp;r) const noexcept { return val == r.val; }&#10;    constexpr bool operator!=(const Mint &amp;r) const noexcept { return !((*this) == r); }&#10;    constexpr bool operator&lt;(const Mint &amp;r) const noexcept { return val &lt; r.val; }&#10;&#10;    constexpr friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint&lt;Modulo&gt; &amp;x) noexcept { return os &lt;&lt; x.val; }&#10;    constexpr friend istream &amp;operator&gt;&gt;(istream &amp;is, Mint&lt;Modulo&gt; &amp;x) noexcept {&#10;        lint tmp{};&#10;        is &gt;&gt; tmp;&#10;        x = Mint(tmp);&#10;        return is;&#10;    }&#10;&#10;    [[nodiscard]] constexpr Mint pow(lint n) const noexcept {&#10;        Mint res{1}, tmp{*this};&#10;        while (n &gt; 0) {&#10;            if (n &amp; 1) res *= tmp;&#10;            tmp *= tmp;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;};&#10;&#10;constexpr int MOD = 1000000007;&#10;using mint = Mint&lt;MOD&gt;;&#10;&#10;int RMOD;&#10;using rmint = Mint&lt;RMOD&gt;;&#10;&#10;//// mod, base from https://gist.github.com/privet-kitty/295ac9202b7abb3039b493f8238bf40f&#10;class RollingHash {&#10;public:&#10;    explicit RollingHash(const string &amp;s) : sz(s.size()) {&#10;&#10;        hash1.assign(sz + 1, 0);&#10;        pow1.assign(sz + 1, 1);&#10;        hash2.assign(sz + 1, 0);&#10;        pow2.assign(sz + 1, 1);&#10;&#10;        for (int i = 0; i &lt; sz; i++) {&#10;            hash1[i + 1] = hash1[i] * base1 + s[i];&#10;            pow1[i + 1] = pow1[i] * base1;&#10;            hash2[i + 1] = hash2[i] * base2 + s[i];&#10;            pow2[i + 1] = pow2[i] * base2;&#10;        }&#10;    }&#10;&#10;    [[nodiscard]] pair&lt;int, int&gt; get(int l, int r) {&#10;        int res1 = (hash1[r] - hash1[l] * pow1[r - l]).val;&#10;        int res2 = (hash2[r] - hash2[l] * pow2[r - l]).val;&#10;        return {res1, res2};&#10;    }&#10;&#10;private:&#10;    static constexpr int prime = 2147483647;&#10;    static constexpr int base1 = 2147483634;&#10;    static constexpr int base2 = 2147483627;&#10;    using Mod = Mint&lt;prime&gt;;&#10;&#10;    vector&lt;Mod&gt; hash1, pow1;&#10;    vector&lt;Mod&gt; hash2, pow2;&#10;    int sz;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myrunlength" value="vector&lt;pair&lt;char, int&gt;&gt; runLength(string s) {&#10;    char prev = s[0];&#10;    vector&lt;pair&lt;char, int&gt;&gt; res{{prev, 0}};&#10;    for (const auto &amp;c : s) {&#10;        if (c == prev) res.back().second++;&#10;        else res.emplace_back(c, 1);&#10;        prev = c;&#10;    }&#10;    return res;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mysegmenttree" value="template&lt;class T, T (*base_op)(T, T), const T(*e) = nullptr&gt;&#10;class Monoid {&#10;    class Identity {};&#10;    constexpr static bool has_identity = (e != nullptr);&#10;public:&#10;    using type = T;&#10;    using vt = conditional_t&lt;has_identity, T, variant&lt;Identity, T&gt;&gt;;&#10;&#10;    [[nodiscard]] constexpr vt op(const vt &amp;a, const vt &amp;b) const {&#10;        if constexpr (has_identity) return base_op(a, b);&#10;        else if (a.index() == 1 &amp;&amp; b.index() == 1) return base_op(get&lt;T&gt;(a), get&lt;T&gt;(b));&#10;        else if (a.index() == 0) return b;&#10;        else return a;&#10;    };&#10;    [[nodiscard]] constexpr vt identity() const {&#10;        if constexpr (has_identity) return *e;&#10;        else return Identity{};&#10;    }&#10;};&#10;&#10;namespace monoid {&#10;    constexpr auto op_add = [](auto l, auto r) { return l + r; };&#10;    constexpr auto op_mul = [](auto l, auto r) { return l * r; };&#10;    constexpr auto op_max = [](auto l, auto r) { return max(l, r); };&#10;    constexpr auto op_min = [](auto l, auto r) { return min(l, r); };&#10;    template&lt;class T&gt; T e_add = T{};&#10;    template&lt;class T&gt; T e_mul = T{1};&#10;    template&lt;class T&gt; T e_max = numeric_limits&lt;T&gt;::max();&#10;    template&lt;class T&gt; T e_min = numeric_limits&lt;T&gt;::min();&#10;    template&lt;class T&gt; using add = Monoid&lt;T, monoid::op_add, &amp;monoid::e_add&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using mul = Monoid&lt;T, monoid::op_mul, &amp;monoid::e_mul&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using max = Monoid&lt;T, monoid::op_max, &amp;monoid::e_max&lt;T&gt;&gt;;&#10;    template&lt;class T&gt; using min = Monoid&lt;T, monoid::op_min, &amp;monoid::e_min&lt;T&gt;&gt;;&#10;}&#10;&#10;inline int clz(lint x) {&#10;    union {&#10;        unsigned long long as_uint64;&#10;        double as_double;&#10;    } data{};&#10;    data.as_double = (double)x + 0.5;&#10;    int n = 1054 - (int)(data.as_uint64 &gt;&gt; 52);&#10;    return 32 + n;&#10;}&#10;&#10;template&lt;class M&gt;&#10;class SegmentTree {&#10;    using T = typename M::type;&#10;    using vt = typename M::vt;&#10;public:&#10;    explicit SegmentTree(const int &amp;n_)&#10;            : n(n_), lg(64 - clz(n)), sz(1 &lt;&lt; lg),&#10;              d(2 * sz, m.identity()) {&#10;    }&#10;    explicit SegmentTree(const vector&lt;T&gt; &amp;v)&#10;            : n((int)v.size()), lg(64 - clz(n)), sz(1 &lt;&lt; lg),&#10;              d(2 * sz, m.identity()) {&#10;        for (int i = 0; i &lt; n; i++) d[sz + i] = v[i];&#10;        for (int i = sz - 1; i &gt;= 0; i--) update(i);&#10;    }&#10;&#10;    void set(int k, const vt &amp;x) {&#10;        assert(0 &lt;= k &amp;&amp; k &lt; n);&#10;        k += sz, d[k] = x;&#10;        for (int i = 1; i &lt;= lg; i++) update(k &gt;&gt; i);&#10;    }&#10;    void add(const int &amp;k, const vt &amp;x) { set(k, m.op(d[k + sz], x)); }&#10;&#10;    [[nodiscard]] vt sum(int l, int r) const {&#10;        assert(l &lt;= r);&#10;        vt sml = m.identity(), smr = m.identity();&#10;        l += sz, r += sz;&#10;&#10;        while (l &lt; r) {&#10;            if (l &amp; 1) sml = m.op(sml, d[l++]);&#10;            if (r &amp; 1) smr = m.op(d[--r], smr);&#10;            l &gt;&gt;= 1;&#10;            r &gt;&gt;= 1;&#10;        }&#10;        return m.op(sml, smr);&#10;    }&#10;    [[nodiscard]] vt operator[](const int &amp;k) const {&#10;        assert(0 &lt;= k &amp;&amp; k &lt; n);&#10;        return d[k + sz];&#10;    }&#10;&#10;private:&#10;    M m;&#10;    int n, lg, sz;&#10;    vector&lt;vt&gt; d;&#10;    void update(const int &amp;k) { d[k] = m.op(d[2 * k], d[2 * k + 1]); }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myslideminmax" value="template&lt;class T&gt;&#10;pair &lt;vector&lt;T&gt;, vector&lt;T&gt;&gt; slide_minmax(const vector&lt;T&gt; &amp;v, int k) {&#10;&#10;    deque&lt;int&gt; deq_min, deq_max;&#10;    vector&lt;T&gt; ret_min, ret_max;&#10;    for (int i = 0; i &lt; (int)v.size(); i++) {&#10;&#10;        while (!deq_min.empty() &amp;&amp; v[deq_min.back()] &gt;= v[i]) deq_min.pop_back();&#10;        while (!deq_max.empty() &amp;&amp; v[deq_max.back()] &lt;= v[i]) deq_max.pop_back();&#10;&#10;        deq_min.push_back(i);&#10;        deq_max.push_back(i);&#10;&#10;        if (i - k + 1 &gt;= 0) {&#10;            ret_min.emplace_back(v[deq_min.front()]);&#10;            ret_max.emplace_back(v[deq_max.front()]);&#10;            if (deq_min.front() == i - k + 1) deq_min.pop_front();&#10;            if (deq_max.front() == i - k + 1) deq_max.pop_front();&#10;        }&#10;&#10;    }&#10;    return {ret_min, ret_max};&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mytemplate" value="#ifdef _DEBUG&#10;#include &quot;../../../library/src/debug_template.hpp&quot;&#10;#define DMP(...) dump(#__VA_ARGS__, __VA_ARGS__)&#10;#else&#10;#define DMP(...) ((void)0)&#10;#endif&#10;&#10;#include &lt;cassert&gt;&#10;#include &lt;cstdio&gt;&#10;#include &lt;cmath&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;set&gt;&#10;#include &lt;map&gt;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;queue&gt;&#10;#include &lt;numeric&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;bitset&gt;&#10;#include &lt;variant&gt;&#10;&#10;using namespace std;&#10;using lint = long long;&#10;constexpr int INF = 1010101010;&#10;constexpr lint LINF = 1LL &lt;&lt; 60;&#10;&#10;struct init {&#10;    init() {&#10;        cin.tie(nullptr);&#10;        ios::sync_with_stdio(false);&#10;        cout &lt;&lt; fixed &lt;&lt; setprecision(10);&#10;    }&#10;} init_;&#10;&#10;int main() {&#10;&#10;    return 0;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mytimer" value="class Timer {&#10;public:&#10;    Timer() { reset(); }&#10;&#10;    void reset() {&#10;        start = chrono::high_resolution_clock::now();&#10;    }&#10;&#10;    [[nodiscard]] chrono::microseconds::rep elapsed() const {&#10;        auto end = chrono::high_resolution_clock::now();&#10;        return chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count();&#10;    }&#10;&#10;private:&#10;    chrono::high_resolution_clock::time_point start;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="mytopologicalsort" value="class TopologicalSort {&#10;public:&#10;    explicit TopologicalSort(int n) : V(n), edges(n), used(n) {}&#10;    explicit TopologicalSort(vector&lt;vector&lt;int&gt;&gt; &amp;edges) : V(edges.size()), used(edges.size()) { this-&gt;edges = edges; }&#10;&#10;    void add_edge(int from, int to) { edges[from].emplace_back(to); }&#10;&#10;    vector&lt;int&gt; build() {&#10;        vector&lt;int&gt; res, in(V);&#10;        for (int i = 0; i &lt; V; i++) for (const auto &amp;e : edges[i]) in[e]++;&#10;&#10;        res.reserve(V);&#10;        queue&lt;int&gt; que;&#10;        for (int i = 0; i &lt; V; i++) {&#10;            if (in[i] == 0 &amp;&amp; !used[i]) {&#10;                used[i] = 1;&#10;                que.emplace(i);&#10;            }&#10;        }&#10;        while (!que.empty()) {&#10;            int now = que.front();&#10;            que.pop();&#10;            res.emplace_back(now);&#10;            for (const auto &amp;e : edges[now]) {&#10;                in[e]--;&#10;                if (in[e] == 0) {&#10;                    if (used[e]) return vector&lt;int&gt;(); // unable to sort&#10;                    used[e] = used[now] + 1;&#10;                    que.emplace(e);&#10;                }&#10;            }&#10;        }&#10;&#10;        return res;&#10;    }&#10;&#10;    [[nodiscard]] int longest_path() {&#10;        return *max_element(used.begin(), used.end()) - 1;&#10;    }&#10;&#10;private:&#10;    int V;&#10;    vector&lt;vector&lt;int&gt;&gt; edges;&#10;    vector&lt;int&gt; used;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template><template name="myunionfind" value="class UnionFind {&#10;public:&#10;    explicit UnionFind(int size) : data(size, -1) {}&#10;    [[nodiscard]] int root(int x) { return data[x] &lt; 0 ? x : data[x] = root(data[x]); }&#10;    [[nodiscard]] bool is_same(int x, int y) { return root(x) == root(y); }&#10;    [[nodiscard]] int size(int x) { return -data[root(x)]; }&#10;&#10;    bool unify(int x, int y) {&#10;        x = root(x);&#10;        y = root(y);&#10;        if (x != y) {&#10;            if (data[y] &lt; data[x]) swap(x, y);&#10;            data[x] += data[y];&#10;            data[y] = x;&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;private:&#10;    vector&lt;int&gt; data;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
    </context>
</template></templateSet>
