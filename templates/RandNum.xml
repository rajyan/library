<template name="myrandnum" value="struct RandNum {&#10;&#10;    mt19937 mt;&#10;    RandNum() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}&#10;&#10;    lint operator()(const lint &amp;rand_min, const lint &amp;rand_max) {&#10;        uniform_int_distribution &lt;lint&gt; dist(rand_min, rand_max);&#10;        return dist(mt);&#10;    }&#10;    lint operator()(const lint &amp;rand_max) { return (*this)(0LL, rand_max); }&#10;&#10;    vector&lt;lint&gt; uniq_vec(const int &amp;sz, const lint &amp;rand_min, lint rand_max) {&#10;&#10;        vector&lt;lint&gt; res(sz);&#10;        unordered_map &lt;lint, lint&gt; memo;&#10;        for (int i = 0; i &lt; sz; i++, rand_max--) {&#10;&#10;            lint rand_val = (*this)(rand_min, rand_max);&#10;&#10;            // If rand_max hasn't been replaced yet, fill it with rand_max&#10;            if (memo.find(rand_max) == memo.end()) memo[rand_max] = rand_max;&#10;&#10;            auto val_itr = memo.find(rand_val);&#10;            if (val_itr == memo.end()) { // replace rand_val with rand_max&#10;                memo[rand_val] = memo[rand_max];&#10;            }&#10;            else { // If rand_val has already been replaced&#10;                rand_val = val_itr-&gt;second;&#10;                val_itr-&gt;second = memo[rand_max];&#10;            }&#10;&#10;            res[i] = rand_val;&#10;        }&#10;        return res;&#10;    }&#10;&#10;    template&lt;class Ite&gt;&#10;    void shuf(Ite first, Ite last) { shuffle(first, last, mt); }&#10;&#10;};&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
        <option name="OC_DECLARATION_C" value="true"/>
        <option name="OC_DECLARATION_CPP" value="true"/>
        <option name="OC_STATEMENT_C" value="true"/>
        <option name="OC_STATEMENT_CPP" value="true"/>
    </context>
</template>